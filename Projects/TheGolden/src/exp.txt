#include<util/util.hpp>
#include<util/engine_util.hpp>


const int TN = 100;
const int TR = 20;

struct Matcher {
    uint8_t state[TR];
    uint8_t patterns[TN][TR];
    uint32_t activation[TN];
};

void tick(Matcher* m) {
    // 1. Activation for both
    for(int p = 0; p < TN; p++) {
        m->activation[p] = 0;
        for(int i = 0; i < TR; i++) {
            m->activation[p] += m->state[i] * m->patterns[p][i];
        }
    }
    
    // 2. Release (both try to pull state toward themselves)
    int accumdiff[TR] = {0};
    for(int p = 0; p < TN; p++) {
        if(m->activation[p] > 30000) {
            for(int i = 0; i < TR; i++) {
                int diff = m->patterns[p][i] - m->state[i];
                // m->state[i] += diff >> 4;
                accumdiff[i] = diff >> 4;
            }
        }
    }

    for(int i = 0; i < TR; i++) {
        m->state[i] += accumdiff[i];
    }
    
    // 3. Decay (same)
    for(int i = 0; i < TR; i++) {
        m->state[i] = (m->state[i] * 254) >> 8;
    }
}

void test_learning() {
    Matcher m = {0};
    
    // Initialize patterns randomly
    srand(42);
    for(int p = 0; p < 100; p++) {
        for(int i = 0; i < 20; i++) {
            m.patterns[p][i] = rand() % 256;
        }
    }
    
    // Define input (the "experience")
    uint8_t input[20] = {0};
    input[0] = 200;  // "Red ball"
    input[1] = 180;
    input[2] = 120;
    
    // Training loop
    for(int trial = 0; trial < 100; trial++) {
        // 1. Present input
        memcpy(m.state, input, 20);
        
        // 2. Let it settle
        for(int t = 0; t < 10; t++) {
            tick(&m);
        }
        
        // 3. LEARNING STEP
        for(int p = 0; p < 100; p++) {
            if(m.activation[p] > 30000) {
                // This pattern was active during input
                // Shift it toward the input
                
                for(int i = 0; i < 20; i++) {
                    int diff = input[i] - m.patterns[p][i];
                    m.patterns[p][i] += diff >> 6;  // Learn 1/64 per trial
                }
            }
        }
        
        // 4. Clear input (let it decay)
        memset(m.state, 0, 20);
        for(int t = 0; t < 50; t++) {
            tick(&m);
        }
    }
    
    // TEST: Did any pattern learn the input?
    printf("\nAfter training:\n");
    for(int p = 0; p < 100; p++) {
        // Check if pattern matches input
        int match_score = 0;
        match_score += abs(m.patterns[p][0] - input[0]);
        match_score += abs(m.patterns[p][1] - input[1]);
        match_score += abs(m.patterns[p][2] - input[2]);
        
        if(match_score < 50) {  // Close match
            printf("Pattern %d learned input: [%u, %u, %u]\n",
                   p, m.patterns[p][0], m.patterns[p][1], m.patterns[p][2]);
        }
    }
}

int main() {
    // test_learning();
    Matcher m = {0};

    m.patterns[0][0] = 200;
    m.patterns[0][1] = 180;

    m.state[0] = 100;
    m.state[1] = 90;

    for(int t = 0; t < 100; t++) {
        tick(&m);
        if(t%10==0) {
            print("STAT 0: ",(int)m.state[0]," STAT 1: ",(int)m.state[1]," ACTIV: ",(int)m.activation[0]);
        }
    }
    
    // // Create 10 patterns, each "owning" 2 dimensions
    // for(int p = 0; p < 10; p++) {
    //     m.patterns[p][p*2] = 200;
    //     m.patterns[p][p*2+1] = 180;
    // }
    
    // // Start all dimensions active
    // for(int i = 0; i < 20; i++) {
    //     m.state[i] = 100;
    // }
    
    // // Run
    // for(int t = 0; t < 100; t++) {
    //     tick(&m);
    //     if(t%10==0) {
    //         print(t);
    //         for(int p = 0; p < 10; p++) {
    //             printf("Pattern %d: activation=%u\n", p, m.activation[p]);
    //         }
    //     }
    // }
    
    // // How many patterns still active?
    // int active_count = 0;
    // for(int p = 0; p < 10; p++) {
    //     if(m.activation[p] > 30000) {
    //         active_count++;
    //         //printf("Pattern %d: activation=%u\n", p, m.activation[p]);
    //     }
    // }
    // printf("Total active: %d / 10\n", active_count);
    
    return 0;
}