#include<core/helper.hpp>
#include<core/physics.hpp>
#include<util/meshBuilder.hpp>
#include<util/ml_core.hpp>
#include<util/logger.hpp>
#include<set>
using namespace Golden;
using namespace helper;

const std::string AROOT = root()+"/Projects/TheGolden/assets/";
const std::string IROOT = AROOT+"images/";
const std::string MROOT = AROOT+"models/";

g_ptr<Scene> scene = nullptr;
g_ptr<NumGrid> grid = nullptr;
ivec2 win(2560,1536);

list<int> addToGrid(g_ptr<Single> q) {
     return grid->addToGrid(q->ID,q->getWorldBounds());
}
list<int> removeFromGrid(g_ptr<Single> q) {
     return grid->removeFromGrid(q->ID,q->getWorldBounds());
}

namespace ML {
     // Utility to read big-endian integers
     int32_t read_int(std::ifstream& file) {
          unsigned char bytes[4];
          file.read((char*)bytes, 4);
          return (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3];
     }
     
     std::pair<g_ptr<tensor>, g_ptr<tensor>> load_mnist(
          const std::string& image_file,
          const std::string& label_file,
          int max_samples = -1  // -1 = load all
     ) {
          // Load images
          std::ifstream img_stream(image_file, std::ios::binary);
          if(!img_stream) throw std::runtime_error("Can't open " + image_file);
          
          int magic = read_int(img_stream);
          int num_images = read_int(img_stream);
          int rows = read_int(img_stream);
          int cols = read_int(img_stream);
          
          if(max_samples > 0) num_images = std::min(num_images, max_samples);
          
          // Create tensor with shape [num_images, rows * cols]
          auto images = make<tensor>(list<int>{num_images, rows * cols});
          
          for(int i = 0; i < num_images; i++) {
          for(int j = 0; j < rows * cols; j++) {
               unsigned char pixel;
               img_stream.read((char*)&pixel, 1);
               images->at({i, j}) = pixel / 255.0f;  // normalize to [0,1]
          }
          }
          
          // Load labels
          std::ifstream lbl_stream(label_file, std::ios::binary);
          if(!lbl_stream) throw std::runtime_error("Can't open " + label_file);
          
          magic = read_int(lbl_stream);
          int num_labels = read_int(lbl_stream);
          
          if(max_samples > 0) num_labels = std::min(num_labels, max_samples);
          
          // Create tensor with shape [num_labels, 10] for one-hot encoding
          auto labels = make<tensor>(list<int>{num_labels, 10});
          labels->fill(0.0f);  // Initialize to zeros
          
          for(int i = 0; i < num_labels; i++) {
          unsigned char label;
          lbl_stream.read((char*)&label, 1);
          labels->at({i, (int)label}) = 1.0f;  // one-hot encoding
          }
          
          return {images, labels};
     }
     
     unsigned int mnist_to_texture(g_ptr<tensor> images, int img_index) {
          // Extract one 28x28 image
          int w = 28, h = 28;
          unsigned char* data = new unsigned char[w * h * 4];  // RGBA
          
          for(int i = 0; i < h; i++) {
          for(int j = 0; j < w; j++) {
               // Flip vertically: read from bottom to top
               int flipped_i = (h - 1) - i;
               float val = images->at({img_index, flipped_i * w + j});
               unsigned char pixel = (unsigned char)(val * 255.0f);
               
               int idx = (i * w + j) * 4;
               data[idx + 0] = pixel;
               data[idx + 1] = pixel;
               data[idx + 2] = pixel;
               data[idx + 3] = 255;
          }
          }
          
          GLuint tex;
          glGenTextures(1, &tex);
          glBindTexture(GL_TEXTURE_2D, tex);
          glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, w, h, 0,
                    GL_RGBA, GL_UNSIGNED_BYTE, data);
          
          glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);  // Nearest for pixel art look
          glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
          
          delete[] data;
          return tex;
     }
     
     void run_mnist(g_ptr<Scene> scene, int epochs, int amt = -1) {
          
     }
}

// void benchmark_raycasts() {
//      print("\n========== RAYCAST BENCHMARK ==========\n");
     
//      // Setup test environment
//      grid = make<NumGrid>(0.5f, 1000.0f);
//      g_ptr<Physics> phys = make<Physics>();
//      Window window = Window(win.x()/2, win.y()/2, "Golden 0.0.5");
//      g_ptr<Scene> test_scene = make<Scene>(window, 2);
//      phys->scene = test_scene;
     
//      // Create maze walls in both structures
//      list<g_ptr<Single>> walls;
//      g_ptr<Model> wall_model = make<Model>(makeTestBox(1.0f));
     
//      for(int i = 0; i < 500; i++) {
//          g_ptr<Single> wall = make<Single>(wall_model);
//          test_scene->add(wall);
//          vec3 pos(randf(-50, 50), 1.5f, randf(-50, 50));
//          wall->setPosition(pos);
//          wall->setPhysicsState(P_State::FREE);
//          grid->addToGrid(wall->ID, wall->getWorldBounds());
//          walls << wall;
//      }
     
//      // Build tree once for static geometry
//      phys->buildTree3d();
     
//      // Test positions and directions
//      vec3 origins[10];
//      vec3 directions[10];
//      for(int i = 0; i < 10; i++) {
//          origins[i] = vec3(randf(-40, 40), 1.0f, randf(-40, 40));
//          directions[i] = vec3(randf(-1, 1), 0, randf(-1, 1)).normalized();
//      }

//      int hits_tree = 0, hits_grid = 0;
//      for(int i = 0; i < 10; i++) {
//      float tree_dist = phys->raycast(origins[i], directions[i], 10.0f);
//      float grid_dist = grid->raycast(origins[i], directions[i], 10.0f);
     
//      if(tree_dist < 10.0f) hits_tree++;
//      if(grid_dist < 10.0f) hits_grid++;
     
//      print("Ray ", i, " - Tree: ", tree_dist, " Grid: ", grid_dist);
//      }
//      print("Tree hits: ", hits_tree, " Grid hits: ", hits_grid);
     
//      Log::rig r;
     
//      // Tree raycast
//      r.add_process("tree_raycast", [&](int i) {
//          int idx = i % 10;
//          phys->raycast(origins[idx], directions[idx], 10.0f);
//      });
     
//      // Grid raycast
//      r.add_process("grid_raycast", [&](int i) {
//          int idx = i % 10;
//          grid->raycast(origins[idx], directions[idx], 10.0f);
//      });
     
//      // Grid raycast with exclusion
//      r.add_process("grid_raycast_with_exclusion", [&](int i) {
//          int idx = i % 10;
//          grid->raycast(origins[idx], directions[idx], 10.0f, 0); // Exclude ID 0
//      });
     
//      // Tree raycast (fresh rebuild each time - worst case)
//      r.add_process("tree_rebuild_raycast", [&](int i) {
//           if(i<3) {
//                phys->treeBuilt3d = false;
//                phys->buildTree3d();
//           }
//          int idx = i % 10;
//          phys->raycast(origins[idx], directions[idx], 10.0f);
//      }, 1); // Separate table
     
//      r.add_comparison("grid_raycast", "tree_raycast");
//      r.add_comparison("grid_raycast_with_exclusion", "grid_raycast");
//      r.add_comparison("tree_rebuild_raycast", "tree_raycast");
     
//      r.run(1000, true, 1000); // 1000 iterations, warm cache, 1000 operations each
//  }
 
g_ptr<Single> draw_line(vec3 start, vec3 end, std::string color, float height) {
     g_ptr<Single> line = scene->create<Single>(color);
     
     float dist = start.distance(end);
     line->setScale({0.1f, 0.1f, dist});
     
     // Set position first
     vec3 midpoint = (start + end) * 0.5f;
     midpoint.y(height); // Set height
     line->setPosition(midpoint);
     
     // Then orient toward end
     line->faceTo(end);
     
     return line;
 }
 void make_maze(g_ptr<Model> wall_model) {
     float maze_size = 50.0f;
     float wall_thickness = 1.0f;
     float wall_height = 3.0f;
     int grid_rows = 10;
     int grid_cols = 10;
     float cell_size = maze_size / grid_rows;
 
     // Helper to place wall segment
     auto place_wall = [&](vec3 pos, vec3 scale) {
         g_ptr<Single> wall = make<Single>(wall_model);
         scene->add(wall);
         wall->dtype = "wall";
         wall->setPosition(pos);
         wall->setScale(scale);
         wall->setPhysicsState(P_State::PASSIVE);
         addToGrid(wall);
     };
 
     // Maze grid: track which walls exist
     // For each cell, track: [north, east, south, west] walls
     struct Cell {
         bool visited = false;
         bool walls[4] = {true, true, true, true}; // N, E, S, W
     };
     
     Cell cells[10][10];
     
     // Recursive backtracking maze generation
     std::function<void(int, int)> carve_path = [&](int row, int col) {
         cells[row][col].visited = true;
         
         // Randomized directions
         int dirs[4] = {0, 1, 2, 3}; // N, E, S, W
         for(int i = 0; i < 4; i++) {
             int j = randi(i, 3);
             std::swap(dirs[i], dirs[j]);
         }
         
         for(int d = 0; d < 4; d++) {
             int next_row = row;
             int next_col = col;
             
             switch(dirs[d]) {
                 case 0: next_row--; break; // North
                 case 1: next_col++; break; // East
                 case 2: next_row++; break; // South
                 case 3: next_col--; break; // West
             }
             
             // Check bounds
             if(next_row < 0 || next_row >= grid_rows || 
                next_col < 0 || next_col >= grid_cols) continue;
             
             if(!cells[next_row][next_col].visited) {
                 // Remove walls between current and next
                 cells[row][col].walls[dirs[d]] = false;
                 cells[next_row][next_col].walls[(dirs[d] + 2) % 4] = false;
                 carve_path(next_row, next_col);
             }
         }
     };
     
     // Start from top-left corner
     carve_path(0, 0);
     
     // Clear center 2x2 area
     int center_row = grid_rows / 2;
     int center_col = grid_cols / 2;
     for(int r = center_row - 1; r <= center_row; r++) {
         for(int c = center_col - 1; c <= center_col; c++) {
             if(r >= 0 && r < grid_rows && c >= 0 && c < grid_cols) {
                 cells[r][c].walls[0] = false; // North
                 cells[r][c].walls[1] = false; // East
                 cells[r][c].walls[2] = false; // South
                 cells[r][c].walls[3] = false; // West
             }
         }
     }
     
     // Create entrance at edge (remove north wall of cell 0,0)
     cells[0][0].walls[0] = false;
     
     // Build walls from cell data
     for(int row = 0; row < grid_rows; row++) {
         for(int col = 0; col < grid_cols; col++) {
             float x = -maze_size/2 + col * cell_size;
             float z = -maze_size/2 + row * cell_size;
             
             // North wall
             if(cells[row][col].walls[0] && row > 0) {
                 place_wall(vec3(x + cell_size/2, wall_height/2, z), 
                           vec3(cell_size, wall_height, wall_thickness));
             }
             
             // East wall
             if(cells[row][col].walls[1] && col < grid_cols - 1) {
                 place_wall(vec3(x + cell_size, wall_height/2, z + cell_size/2), 
                           vec3(wall_thickness, wall_height, cell_size));
             }
             
             // South wall
             if(cells[row][col].walls[2] && row < grid_rows - 1) {
                 place_wall(vec3(x + cell_size/2, wall_height/2, z + cell_size), 
                           vec3(cell_size, wall_height, wall_thickness));
             }
             
             // West wall
             if(cells[row][col].walls[3] && col > 0) {
                 place_wall(vec3(x, wall_height/2, z + cell_size/2), 
                           vec3(wall_thickness, wall_height, cell_size));
             }
         }
     }
     
     // Outer boundary walls (to enclose maze)
     // North boundary
     for(int col = 0; col < grid_cols; col++) {
         float x = -maze_size/2 + col * cell_size;
         if(cells[0][col].walls[0]) { // Only if not entrance
             place_wall(vec3(x + cell_size/2, wall_height/2, -maze_size/2), 
                       vec3(cell_size, wall_height, wall_thickness));
         }
     }
     
     // South boundary
     for(int col = 0; col < grid_cols; col++) {
         float x = -maze_size/2 + col * cell_size;
         place_wall(vec3(x + cell_size/2, wall_height/2, maze_size/2), 
                   vec3(cell_size, wall_height, wall_thickness));
     }
     
     // West boundary
     for(int row = 0; row < grid_rows; row++) {
         float z = -maze_size/2 + row * cell_size;
         place_wall(vec3(-maze_size/2, wall_height/2, z + cell_size/2), 
                   vec3(wall_thickness, wall_height, cell_size));
     }
     
     // East boundary
     for(int row = 0; row < grid_rows; row++) {
         float z = -maze_size/2 + row * cell_size;
         place_wall(vec3(maze_size/2, wall_height/2, z + cell_size/2), 
                   vec3(wall_thickness, wall_height, cell_size));
     }
 }
#define GTIMERS 0
#define VISPATHS 0
// #define CRUMB_ROWS 40 
// // Packed ints with start / count so we can be more dynamic!
// const int META  = (0 << 16) | 1; 
// const int IS    = (1 << 16) | 10;
// const int DOES  = (11 << 16) | 10;
// const int WANTS = (21 << 16) | 10;
// const int HAS   = (31 << 16) | 9;
// const int ALL = (0 << 16) | CRUMB_ROWS;

#define CRUMB_ROWS 20
// Packed ints with start / count so we can be more dynamic!
const int META  = (0 << 16) | 1; 
const int IS    = (1 << 16) | 5;
const int DOES  = (6 << 16) | 5;
const int WANTS = (11 << 16) | 5;
const int HAS   = (16 << 16) | 5;
const int ALL = (0 << 16) | CRUMB_ROWS;

struct crumb {

     crumb() {
          for(int r = 0; r < CRUMB_ROWS; r++) {
               for(int c = 0; c < 10; c++) {
                   mat[r][c] = 0.0f;
               }
           }
     }

     g_ptr<Single> form = nullptr;
     float mat[CRUMB_ROWS][10];

     inline void setmat(float v) {
          for(int r = 0; r < CRUMB_ROWS; r++) {
               for(int c = 0; c < 10; c++) {
                   mat[r][c] = v;
               }
           }
     }

     inline float* data() const {
          return (float*)&mat[0][0];
     }
     
     inline int rows() const {
          return CRUMB_ROWS;
     }
};

static float compute_trace(const float* matrix) {
     float trace = 0.0f;
     for(int i = 0; i < CRUMB_ROWS; i++) {
         trace += matrix[i * 10 + i];
     }
     return trace;
}

static void matmul(const float* eval, const float* against, float* result) {
     cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                CRUMB_ROWS, 10, 10,
                1.0f,
                eval, 10,
                against, 10,
                0.0f,
                result, 10);
}

static float evaluate_matmul(const crumb& eval, const crumb& against, crumb& result) {
     matmul(eval.data(), against.data(), result.data());
     return compute_trace(result.data());
 }
 
 static float evaluate_matmul(const crumb& eval, const crumb& against) {
     crumb result{};
     return evaluate_matmul(eval, against, result);
 }
 

static float evaluate_elementwise(const crumb& eval, int eval_verb, const crumb& against, int against_verb) {
     int eval_start = (eval_verb >> 16) & 0xFFFF;
     int eval_count = eval_verb & 0xFFFF;
     int against_start = (against_verb >> 16) & 0xFFFF;
     int against_count = against_verb & 0xFFFF;

     assert(eval_count == against_count); 

     float score = 0.0f;
     const float* eval_ptr = &eval.mat[eval_start][0];
     const float* against_ptr = &against.mat[against_start][0];
     int total = eval_count * 10;
     for(int i = 0; i < total; i++) {
          score += eval_ptr[i] * against_ptr[i];
     }

     return score;
}

static float evaluate(const crumb& eval, int eval_verb, const crumb& against, int against_verb) {
    return evaluate_elementwise(eval, eval_verb, against, against_verb);
}

static float evaluate_binary(const crumb& a, int a_verb, const crumb& b, int b_verb) {
     int a_start = (a_verb >> 16) & 0xFFFF;
     int a_count = a_verb & 0xFFFF;
     int b_start = (b_verb >> 16) & 0xFFFF;
     int b_count = b_verb & 0xFFFF;
     
     assert(a_count == b_count);
     
     float* a_ptr = (float*)&a.mat[a_start][0];
     float* b_ptr = (float*)&b.mat[b_start][0];
     
     int total_elements = a_count * 10;
     int matching_bits = 0;
     int total_bits = total_elements * 32;
     
     for(int i = 0; i < total_elements; i++) {
         uint32_t a_bits = *(uint32_t*)&a_ptr[i];
         uint32_t b_bits = *(uint32_t*)&b_ptr[i];
         uint32_t xor_result = a_bits ^ b_bits;
         uint32_t matching = ~xor_result;
         matching_bits += __builtin_popcount(matching);
     }
     return (float)matching_bits / (float)total_bits;
 }

template<typename Op>
static void apply_mask(crumb& target, int target_verb, const crumb& mask, int mask_verb, Op op) {
    int target_start = (target_verb >> 16) & 0xFFFF;
    int target_count = target_verb & 0xFFFF;
    int mask_start = (mask_verb >> 16) & 0xFFFF;
    int mask_count = mask_verb & 0xFFFF;
    
    assert(target_count == mask_count);
    
    float* target_ptr = &target.mat[target_start][0];
    const float* mask_ptr = &mask.mat[mask_start][0];
    int total = target_count * 10;
    
    for(int i = 0; i < total; i++) {
        target_ptr[i] = op(target_ptr[i], mask_ptr[i]);
    }
}

static void mult_mask(crumb& t, int tv, const crumb& m, int mv) {
    apply_mask(t, tv, m, mv, [](float a, float b) { return a * b; });
}

static void div_mask(crumb& t, int tv, const crumb& m, int mv) {
    apply_mask(t, tv, m, mv, [](float a, float b) { return a / b; });
}

static void add_mask(crumb& t, int tv, const crumb& m, int mv) {
    apply_mask(t, tv, m, mv, [](float a, float b) { return a + b; });
}

static void scale_mask(crumb& target, int verb, float scalar) {
     int start = (verb >> 16) & 0xFFFF;
     int count = verb & 0xFFFF;
     float* ptr = &target.mat[start][0];
     int total = count * 10;
     
     for(int i = 0; i < total; i++) {
         ptr[i] *= scalar;
     }
 }
 

 static crumb randcrumb() {
     crumb seed;
     for(int r=0; r<CRUMB_ROWS; r++)
          for(int c=0; c<10; c++)
               seed.mat[r][c] = randf(-1, 1);
     return seed;
 }

struct crumb_store : public q_object {
     list<crumb> crumbs;
};

struct CategoryNode : public q_object {

     CategoryNode() {
          store = make<crumb_store>();
          for(int i = 0; i < CRUMB_ROWS; i++)
               for(int j = 0; j < 10; j++)
                    cmask.mat[i][j] = 1.0f;
     }
     CategoryNode(std::string _label) {
          label = _label;
          store = make<crumb_store>();
          for(int i = 0; i < CRUMB_ROWS; i++)
               for(int j = 0; j < 10; j++)
                    cmask.mat[i][j] = 1.0f;
     }

     std::string label;
     crumb archetype;
     crumb cmask;
     
     // Tree structure
     list<CategoryNode*> parents;
     list<g_ptr<CategoryNode>> children;
     g_ptr<crumb_store> store = nullptr;

     //DEBUG ONLY METHOD
     vec3 getPosition() {
          if(archetype.form) return archetype.form->getPosition();
          else return vec3(0,0,0);
     }

     //DEBUG ONLY METHOD
     int getID() {
          if(archetype.form) return archetype.form->ID;
          else return -1;
     }

     bool operator==(g_ptr<CategoryNode> other) {
          return *this == other.getPtr();
     }
          
     list<crumb>& get_crumbs() {
          return store->crumbs;
     }

     void set_crumbs(list<crumb>& n_crumbs) {
          store->crumbs = std::move(n_crumbs);
     }

     void add_to_category(crumb& n_crumb) {
          get_crumbs() << n_crumb;
      }
     
     g_ptr<CategoryNode> create_category(const crumb& seed, std::string label = "undefined") {
         g_ptr<CategoryNode> new_cat = make<CategoryNode>(label);
         new_cat->archetype = std::move(seed);
         new_cat->parents << this;
         children << new_cat;
         
         return new_cat;
     }

     void split(const list<list<int>>& to_split, int verb = ALL) {
          for(int s = 0; s<to_split.length();s++) {
               list<crumb> crumbs;
               for(int i=0;i<to_split[s].length();i++) {
                    crumbs.push(get_crumbs()[to_split[s][i]]);
               }
               
               crumb new_arc;
               for(crumb& c : crumbs) {
                    add_mask(new_arc,verb,c,verb);
               }
               scale_mask(new_arc,verb,1.0f / crumbs.length());

               auto new_cat = create_category(new_arc);
               new_cat->set_crumbs(crumbs);
          }
     }

     list<list<int>> kmeans_partition(const list<crumb>& crumbs, int k, int verb, const crumb& mask) {
          if(crumbs.length() < k * 2) {
              // Not enough data, return single cluster
              list<list<int>> result;
              list<int> all;
              for(int i = 0; i < crumbs.length(); i++) all << i;
              result << all;
              return result;
          }
          
          // Create masked copies of all crumbs upfront
          list<crumb> masked_crumbs;
          for(const crumb& c : crumbs) {
              crumb masked = c;  // Copy
              mult_mask(masked, verb, mask, verb);
              masked_crumbs << masked;
          }
          
          // Initialize: pick k random distinct crumbs as starting centroids
          list<crumb> centroids;
          list<int> used;
          for(int i = 0; i < k; i++) {
              int idx;
              do {
                  idx = randi(0, crumbs.length() - 1);
              } while(used.has(idx));
              
              used << idx;
              centroids << masked_crumbs[idx];  // Use masked version
          }
          
          // Iterate until stable (max 10 iterations)
          list<list<int>> clusters;
          
          for(int iter = 0; iter < 10; iter++) {
              // Clear clusters
              clusters.clear();
              for(int i = 0; i < k; i++) clusters << list<int>{};
              
              // Assign each crumb to closest centroid
              for(int i = 0; i < masked_crumbs.length(); i++) {
                  float best_score = -1e9f;
                  int best_k = 0;
                  
                  for(int j = 0; j < k; j++) {
                      float score = evaluate(masked_crumbs[i], verb, centroids[j], verb);
                      if(score > best_score) {
                          best_score = score;
                          best_k = j;
                      }
                  }
                  
                  clusters[best_k] << i;
              }
              
              // Recompute centroids from assignments
              for(int j = 0; j < k; j++) {
                  if(clusters[j].empty()) continue;
                  
                  // Zero out
                  for(int r = 0; r < CRUMB_ROWS; r++)
                      for(int c = 0; c < 10; c++)
                          centroids[j].mat[r][c] = 0.0f;
                  
                  // Sum
                  for(int idx : clusters[j]) {
                      add_mask(centroids[j], verb, masked_crumbs[idx], verb);
                  }
                  
                  // Average
                  scale_mask(centroids[j], verb, 1.0f / clusters[j].length());
              }
          }
          
          // Filter empty clusters
          list<list<int>> result;
          for(const list<int>& cluster : clusters) {
              if(cluster.length() >= 1) {
                  result << cluster;
              }
          }
          
          return result;
      }
     list<list<int>> kmeans_partition(const list<crumb>& crumbs, int k, int verb = ALL) {
          return kmeans_partition(crumbs,k,verb,cmask);
     }

     void update(int verb, const crumb& mask) {
          if(get_crumbs().length() < 5) return;  // Too small
    
          // Calculate coherence
          float total_similarity = 0.0f;
          for(const crumb& c : get_crumbs()) {
              total_similarity += evaluate(c, verb, archetype, verb);
          }
          float coherence = total_similarity / get_crumbs().length();
          
          if(coherence < 3.0f) {  // Needs split
              int k = randi(2, 3);
              auto clusters = kmeans_partition(get_crumbs(), k, verb);
              split(clusters, verb);
          }
     }
     void update(int verb = ALL) {
          update(verb,cmask);
     }
};

static int total_connections = 0;
static float min_sal = 1.0f;
class crumb_manager : public Object {
public:
     crumb_manager() {
          meta_root = make<CategoryNode>("meta");
          is_root = make<CategoryNode>("is");
          does_root = make<CategoryNode>("does");
          wants_root = make<CategoryNode>("wants");
          has_root = make<CategoryNode>("has");

          physics_attention << meta_root;
          cognitive_attention << is_root;

          for(int i = 0; i < CRUMB_ROWS; i++)
          for(int j = 0; j < 10; j++)
               cmask.mat[i][j] = 1.0f;
     };
     ~crumb_manager() {};

     crumb cmask;

     g_ptr<CategoryNode> meta_root = nullptr;
     g_ptr<CategoryNode> is_root = nullptr;
     g_ptr<CategoryNode> does_root = nullptr;
     g_ptr<CategoryNode> wants_root = nullptr;
     g_ptr<CategoryNode> has_root = nullptr;

     crumb current_state;
     int agent_id = -1;

     int physics_focus = 4;
     list<g_ptr<CategoryNode>> physics_attention; 
     int cognitive_focus = 8;
     list<g_ptr<CategoryNode>> cognitive_attention;

     map<int, CategoryNode*> id_to_node; 
     list<g_ptr<Single>> debug;

     void clear_debug() {
          for(auto d : debug) { 
               scene->transforms[d->ID] = glm::mat4(1.0f);
               scene->recycle(d); 
          }
          debug.clear();
      }
     g_ptr<CategoryNode> has_seen_before_cheat(const crumb& thing) {
         if(thing.form == nullptr) return nullptr;
         CategoryNode* fallback = nullptr;
         CategoryNode* ptr = id_to_node.getOrDefault(thing.form->ID,fallback);
         if(ptr)
              return g_ptr<CategoryNode>(ptr);
         else
              return nullptr;
     }
     void visualize_structure(g_ptr<CategoryNode> root = nullptr) {
          clear_debug();
          if(!root) root = physics_attention.empty() ? meta_root : physics_attention.last();
          
        
          std::set<int> visited_form_ids; // Track by form ID
          list<g_ptr<CategoryNode>> visited_nodes;
          
          list<g_ptr<CategoryNode>> stack;
          stack << root;
          


          while(!stack.empty()) {
              g_ptr<CategoryNode> current = stack.last();
              stack.pop();
              
              if(!current->archetype.form) continue; // Skip nodes without forms
              
              int form_id = current->archetype.form->ID;
              if(visited_form_ids.count(form_id) > 0) continue;
              visited_form_ids.insert(form_id);
              visited_nodes << current;
              
              for(auto child : current->children) {
                  if(child->archetype.form && visited_form_ids.count(child->archetype.form->ID) == 0) {
                      stack << child;
                  }
              }
              
              for(auto parent_raw : current->parents) {
                  g_ptr<CategoryNode> parent(parent_raw);
                  if(parent->archetype.form && visited_form_ids.count(parent->archetype.form->ID) == 0) {
                      stack << parent;
                  }
              }
          }

          
          std::set<std::pair<int,int>> drawn_edges; // Track edges by form ID pairs
          
          for(auto current : visited_nodes) {
              int current_id = current->archetype.form->ID;
                            
               std::string make_color = "green";
               if(current->archetype.mat[0][1] < 3.0f) make_color = "white";
               if(current->archetype.form == root->archetype.form) make_color = "black";

               auto marker = scene->create<Single>(make_color);
               if(current->children.empty())
               marker->setScale(vec3(0.3, 2, 0.3));
               else
               marker->setScale(std::min(2.0f, (float)current->children.length() / 2.0f));

               marker->setPosition(current->getPosition().addY(2.0f+(current->getID()/100.0f)));
               if(current->archetype.form == root->archetype.form) {
               marker->move({0, 2.0f, 0});
               marker->setScale(vec3(0.5f, 2.5f, 0.5f));
               }
               debug << marker;
              
              // Draw children
              for(auto child : current->children) {
                  if(!child->archetype.form) continue;
                  int child_id = child->archetype.form->ID;
                  
                  if(visited_form_ids.count(child_id) > 0) {
                      auto edge = std::make_pair(std::min(current_id, child_id), std::max(current_id, child_id));
                      if(drawn_edges.count(edge) == 0) {
                          debug << draw_line(current->getPosition(), child->getPosition(), "blue", 1.9f+(current->getID()/70.0f));
                          drawn_edges.insert(edge);
                      }
                  }
              }
              
              // Draw parents
              for(auto parent_raw : current->parents) {
                  g_ptr<CategoryNode> parent(parent_raw);
                  if(!parent->archetype.form) continue;
                  int parent_id = parent->archetype.form->ID;
                  
                  if(visited_form_ids.count(parent_id) > 0) {
                      auto edge = std::make_pair(std::min(current_id, parent_id), std::max(current_id, parent_id));
                      if(drawn_edges.count(edge) == 0) {
                          debug << draw_line(current->getPosition(), parent->getPosition(), "yellow", 2.2f+(current->getID()/70.0f));
                          drawn_edges.insert(edge);
                      }
                  }
              }
          }

          auto mark = scene->create<Single>("cyan");
          mark->setPosition(physics_attention.last()->getPosition().addY(5.0f));
          mark->setScale({0.5f, 1.5f, 0.5f});
          debug << mark;
     }
     void visualize_registry(g_ptr<CategoryNode> root = nullptr) {
          clear_debug();
          if(!root) root = meta_root;
          std::set<std::pair<int,int>> drawn_edges;
          
          // Iterate through all registered nodes
          for(auto entry : id_to_node.entrySet()) {
              int form_id = entry.key;
              g_ptr<CategoryNode> current(entry.value);
              
              if(!current->archetype.form) continue;
              
              // Draw node marker
              std::string make_color = "green";
              if(current->archetype.mat[0][1] < 3.0f) make_color = "white";
              if(current->archetype.form == root->archetype.form) make_color = "black";

              auto marker = scene->create<Single>(make_color);
              if(current->children.empty())
              marker->setScale(vec3(0.3, 1.5f, 0.3));
              else
              marker->setScale(std::min(2.0f, (float)current->children.length() / 2.0f));

              marker->setPosition(current->getPosition().addY(2.0f));
              if(current->archetype.form == root->archetype.form) {
               marker->move({0, 2.0f, 0});
               marker->setScale(vec3(0.5f, 1.5f, 0.5f));
              }
              debug << marker;
              
              // Draw blue lines to children
              for(auto child : current->children) {
                  if(!child->archetype.form) continue;
                  int child_id = child->archetype.form->ID;
               debug << draw_line(current->getPosition(), child->getPosition(), "blue", 1.9f);
              }
              
              // Draw yellow lines to parents
              for(auto parent_raw : current->parents) {
                  g_ptr<CategoryNode> parent(parent_raw);
                  if(!parent->archetype.form) continue;
                  int parent_id = parent->archetype.form->ID;
               debug << draw_line(current->getPosition(), parent->getPosition(), "yellow", 2.2f);
              }
          }
          
          // Draw attention markers
          // for(auto a : physics_attention) {
          //     if(!a->archetype.form) continue;
          //     auto mark = scene->create<Single>("cyan");
          //     mark->setPosition(a->getPosition().addY(3.0f));
          //     if(a == physics_attention.last()) 
          //         mark->setScale(1.0f);
          //     else 
          //         mark->setScale({0.5f, 1.5f, 0.5f});
          //     debug << mark;
          // }
      }
      void find_duplicates() {
          print("=== DUPLICATE CHECK ===");
          print("Total forms registered: ", id_to_node.size());
          
          // Group nodes by their actual node pointer to find if same node appears multiple times
          map<CategoryNode*, int> node_use_count;
          
          for(auto entry : id_to_node.entrySet()) {
              node_use_count[entry.value]++;
          }
          
          // Check if any node is registered to multiple forms (shouldn't happen)
          int shared_nodes = 0;
          for(auto e : node_use_count.entrySet()) {
              if(e.value > 1) {
                  print("WARNING: Node at ", (void*)e.key, " is registered to ", e.value, " different forms!");
                  shared_nodes++;
              }
          }
          
          if(shared_nodes == 0) {
              print("âœ“ No shared nodes - each form has unique node");
          }
          
          // Now traverse the actual graph and see if there are nodes NOT in the registry
          std::set<void*> all_graph_nodes;
          std::set<void*> visited;
          list<g_ptr<CategoryNode>> stack;
          
          if(!physics_attention.empty()) {
              stack << physics_attention.last();
              
              while(!stack.empty()) {
                  auto current = stack.last();
                  stack.pop();
                  
                  void* ptr = (void*)current.getPtr();
                  if(visited.count(ptr) > 0) continue;
                  visited.insert(ptr);
                  all_graph_nodes.insert(ptr);
                  
                  for(auto child : current->children) stack << child;
                  for(auto parent : current->parents) stack << parent;
              }
          }
          
          print("Total nodes in graph: ", all_graph_nodes.size());
          print("Nodes in registry: ", id_to_node.size());
          
          // Check for orphaned nodes (in graph but not in registry)
          int orphaned = 0;
          for(void* graph_node : all_graph_nodes) {
              bool found = false;
              for(auto entry : id_to_node.entrySet()) {
                  if((void*)entry.value == graph_node) {
                      found = true;
                      break;
                  }
              }
              if(!found) {
                  print("ORPHANED: Node at ", graph_node, " is in graph but not in registry");
                  orphaned++;
              }
          }
          
          print("Orphaned nodes: ", orphaned);
          print("======================");
      }

     inline float navigation_focus() const {
          return current_state.mat[0][1];
     }

     float spatial_salience(const crumb& observation) {
          return evaluate(current_state, META, observation, META);
     }

     float desire_salience(const crumb& observation) {
          return evaluate(current_state, WANTS, observation, IS);
     }

     float salience(const crumb& observation) {
          float sp_sal = spatial_salience(observation);
          float ds_sal = desire_salience(observation);
          // print("SP_SAL: ",sp_sal);
          // print("DS_SAL: ",ds_sal);
          // print("NAV FOCUS: ",navigation_focus());
          // print("SAL: ",std::lerp(sp_sal,ds_sal,navigation_focus()));
          return std::lerp(ds_sal,sp_sal,navigation_focus());
     }

     bool in_attention(crumb& thing) {
          for(auto recent : physics_attention)
          { if(thing.form==recent->archetype.form) return true; }
          return false;
     }

     float relevance(crumb& thing, float sal) {
          if(sal < min_sal) return 0.0f;
          float min_current_salience = min_sal;
          for(auto attended : physics_attention) {
              float attended_sal = salience(attended->archetype);
              if(attended_sal < min_current_salience) {
                  min_current_salience = attended_sal;
              }
              //print("ATTENDED SAL = ",attended_sal);
          }
          // print("THIS SAL: ",sal);
          // print("MIN_CURR_SAL: ",min_current_salience);
          if(min_current_salience==0) return 1.0f; //Just to stop those inf returns
          float relative_score = (sal - min_current_salience * 0.9f) / min_current_salience;
          return std::max(0.0f, relative_score);
      }

     void push_attention_head(g_ptr<CategoryNode> node) {
          int found_id = physics_attention.find(node);
          if(found_id!=-1) {
               physics_attention << physics_attention[found_id];
               physics_attention.removeAt(found_id);
          } else {
               physics_attention << node;
               if(physics_attention.length()>physics_focus) {
                    physics_attention.removeAt(0);
               }
          }
     }

     g_ptr<CategoryNode> closest_visible_node(const vec3& pos, list<int> exclude_ids = list<int>{}, list<std::string> match_dtype = list<std::string>{}) {
          float best_dist = 1000.0f;
          g_ptr<CategoryNode> best_node = nullptr;
          exclude_ids << agent_id;
          for(auto e : id_to_node.entrySet()) {
               if(!match_dtype.empty()) {
                    bool cont = false;
                    for(auto s : match_dtype) {
                         if(scene->singles[e.key]->dtype!=s) {
                              cont = true; break;
                         }
                    }
                    if(cont) continue;
               }

               vec3 npos = vec3(scene->transforms[e.key][3]);
               float dist = npos.distance(pos);
               if(dist<best_dist) {
                    exclude_ids << e.key;
                    if(grid->can_see(npos,pos,exclude_ids)) {
                         best_node = g_ptr<CategoryNode>(e.value);
                         best_dist = dist;
                    }
                    exclude_ids.pop();
               }
          }
          return best_node;
     }
     g_ptr<CategoryNode> closest_visible_node(g_ptr<Single> single) {
          return closest_visible_node(single->getPosition(),{single->ID},{single->dtype});
     }

     g_ptr<CategoryNode> observe(crumb& thing,g_ptr<Single> single) {
          g_ptr<CategoryNode> node = make<CategoryNode>();
          node->archetype = thing;

          int l = physics_attention.length();
          //Do the N last objects of our attention list
          // int n = 1;
          // for(int i= l<n ? 0: l-n ;i<l;i++) {
          //      auto recent = physics_attention[i];
          //      node->parents << recent.getPtr();
          //      recent->children << node;
          //      total_connections += 2;
          // }

          //Should also add some measure of grid collision detection here too
          // float best_dist = 1000.0f;
          // g_ptr<CategoryNode> best_node = physics_attention.last();
          // vec3 pos = single->getPosition();
          // for(auto n : physics_attention) {
          //      float dist = n->getPosition().distance(pos);
          //      if(dist<best_dist) {
          //           if(grid->can_see(n->getPosition(),pos,{agent_id,single->ID,n->getID()})) {
          //                best_node = n;
          //                best_dist = dist;
          //           }
          //      }
          // }
          g_ptr<CategoryNode> best_node = closest_visible_node(single);
          if(!best_node) best_node = physics_attention.last();

          node->parents << best_node.getPtr();
          best_node->children << node;
          total_connections++;

          if(!node->archetype.form) {
               print("OBSERVE WARNING: formless archetpye for category!");
          } else {
               id_to_node.put(node->getID(),node.getPtr());
          }
          // push_attention_head(node);
          return node;
     }

     void decrease_novelty(g_ptr<CategoryNode> seen_before) {
          crumb mask;
          mask.setmat(1.0f); //Initilize to 1.0f
          mask.mat[0][1] = 0.98f;
          mult_mask(seen_before->archetype, META, mask, META);
     }

     void categorize(crumb& thing) {

     }

     g_ptr<CategoryNode> has_seen_before(const crumb& thing, float focus) {
          if(physics_attention.empty()) return nullptr;
          int total_budget = (int)(focus * 500);
          
          list<std::pair<g_ptr<CategoryNode>, int>> stack;
          stack << std::make_pair(physics_attention.last(), total_budget);
          std::set<void*> visited;
          
          while(!stack.empty()) {
              auto [current, budget] = stack.last();
              stack.pop();
              
              if(budget <= 0) {
                    // if(current != nullptr) {
                    // print("Budget exhausted during has_seen_before search");
                    // }
                    continue;
               }
              void* ptr = (void*)current.getPtr();
              if(visited.count(ptr) > 0) continue;
              visited.insert(ptr);
              
              // Check THIS node
              if(current->archetype.form != nullptr && 
                 thing.form == current->archetype.form) {
                  return current;
              }
              
              // Add ALL children to stack (explore downward)
              if(!current->children.empty()) {
                  int budget_per_child = (budget - 1) / current->children.length();
                  for(auto child : current->children) {
                      stack << std::make_pair(child, budget_per_child);
                  }
              }
              
              // Add ALL parents to stack (explore upward)
              if(!current->parents.empty()) {
                  int budget_per_parent = (budget - 1) / current->parents.length();
                  for(auto parent : current->parents) {
                      stack << std::make_pair(parent, budget_per_parent);
                  }
              }
          }
          return nullptr; // Novel
      }

     // Find best matching category for a crumb
     g_ptr<CategoryNode> find_best_category(const crumb& crumb_obj, int verb, g_ptr<CategoryNode> root) {
         g_ptr<CategoryNode> current = root;
         
         while(!current->children.empty()) {
             float best_match = -1e9f;
             g_ptr<CategoryNode> best_child = nullptr;
             
             for(auto child : current->children) {
                 //float match = evaluate_against_archetype(crumb_obj, child);
                 float match = evaluate(crumb_obj, META, child->archetype, META);
                 if(match > best_match) {
                     best_match = match;
                     best_child = child;
                 }
             }
             
             // Only descend if child is significantly better
             if(best_match > 0.5f) {  // Threshold
                 current = best_child;
             } else {
                 break;
             }
         }
         
         return current;
     }

     list<vec3> come_up_with_a_path(int& for_benchmark, int verb_a, int verb_b, const crumb& mask) {
          list<vec3> path;
          
          // print("=== Searching all remembered nodes ===");
          // print("Total nodes in memory: ", id_to_node.size());
          
          g_ptr<CategoryNode> best_target = nullptr;
          float best_relevance = 0.0f; // Minimum threshold
          
          // Search ALL remembered nodes
          for(auto entry : id_to_node.entrySet()) {
              g_ptr<CategoryNode> node(entry.value);
              for_benchmark++;
              
              crumb against = node->archetype;
              mult_mask(against, verb_b, mask, verb_b);
              float sal = salience(against);
              float rel = relevance(against, sal);
              
              if(rel > best_relevance) {
                  best_relevance = rel;
                  best_target = node;
              }
          }
          
          if(best_target == nullptr) {
          //     print("No suitable target found in memory");
              return path;
          }
          
          // print("Found target: ", best_target->archetype.form->dtype, 
          //       " with relevance=", best_relevance);
          
          // Now build path from current position to target via graph traversal
          // Use BFS to find shortest path through parent/child connections
          map<CategoryNode*, CategoryNode*> came_from;
          list<g_ptr<CategoryNode>> queue;
          std::set<void*> visited;
          
          g_ptr<CategoryNode> start = physics_attention.last();
          queue << start;
          visited.insert((void*)start.getPtr());
          came_from.put(start.getPtr(), nullptr);
          
          bool found = false;
          while(!queue.empty() && !found) {
              g_ptr<CategoryNode> current = queue.first();
              queue.removeAt(0);
              
              if(current == best_target) {
                  found = true;
                  break;
              }
              
              // Check children
              for(auto child : current->children) {
                  void* ptr = (void*)child.getPtr();
                  if(visited.count(ptr) == 0) {
                      visited.insert(ptr);
                      came_from.put(child.getPtr(), current.getPtr());
                      queue << child;
                  }
              }
              
              // Check parents
              for(auto parent_raw : current->parents) {
                  g_ptr<CategoryNode> parent(parent_raw);
                  void* ptr = (void*)parent.getPtr();
                  if(visited.count(ptr) == 0) {
                      visited.insert(ptr);
                      came_from.put(parent.getPtr(), current.getPtr());
                      queue << parent;
                  }
              }
          }
          
          if(!found) {
          //     print("Target exists but no path found in graph");
              return path;
          }
          
          // Reconstruct path from target back to start
          list<vec3> reversed_path;
          CategoryNode* current = best_target.getPtr();
          while(current != nullptr) {
              if(current->archetype.form != nullptr) {
                  vec3 pos = current->getPosition();
                  reversed_path << pos;
                  //print("  Added waypoint: ", pos.to_string());
                  
                  #if VISPATHS
                    auto marker = scene->create<Single>("black");
                    marker->setScale(std::min(2.0f, (float)current->children.length() / 2.0f));
                    marker->setPosition(pos.addY(4.0f));
                    debug << marker;
                  #endif
              }
              CategoryNode* fallback = nullptr;
              current = came_from.getOrDefault(current, fallback);
          }
          
          // Reverse so path goes from start -> target
          for(int i = reversed_path.length()-1; i >= 0; i--) {
              path << reversed_path[i];
          }
          
          // print("Path complete with ", path.length(), " waypoints");
          return path;
      }
      list<vec3> come_up_with_a_path(int& for_benchmark) {
          return come_up_with_a_path(for_benchmark,WANTS,IS,cmask);
      }
};


static const int MAX_BUFFER_SIZE = 500;
static const int MIN_BUFFER_SIZE = 64;
static const int BATCH_SIZE = 16;

 
struct HotColdLearner : public Object {
     // Network weights
     g_ptr<tensor> w1, b1, w2, b2;
     list<g_ptr<tensor>> params;  
     g_ptr<optimizer> brain;
     
     // IMPORTANT: Store Pass objects so they persist
     Pass matmul1_pass, add1_pass, relu_pass, matmul2_pass, add2_pass;
     Pass loss_pass;
     
     vec3 hidden_target;
     float last_distance;

     float cumulative_reward = 0;
     int steps_taken = 0;
     int times_reached_goal = 0;
     float best_distance = 1000.0f;
     
     struct Experience {
         g_ptr<tensor> state;
         int action;
         float reward;
     };
     
     // EXPERIENCE REPLAY - simple FIFO, no priority
     list<Experience> replay_buffer;
     static const int MAX_BUFFER_SIZE = 1000;
     static const int MIN_BUFFER_SIZE = 100;
     static const int BATCH_SIZE = 32;
   
     void init(vec3 start_pos, vec3 target) {
         w1 = weight(6, 64, 0.1f);
         b1 = bias(64);
         w2 = weight(64, 4, 0.1f);
         b2 = bias(4);
         
         params = {w1, b1, w2, b2};
         brain = make<optm_adam>(params, 0.05f);  // Higher initial LR for faster learning
         
         // Initialize Pass objects ONCE
         matmul1_pass = {MATMUL, w1};
         add1_pass = {ADD, b1};
         relu_pass = {RELU};
         matmul2_pass = {MATMUL, w2};
         add2_pass = {ADD, b2};
         
         hidden_target = target;
         last_distance = start_pos.distance(target);
     }
   
     g_ptr<tensor> encode_state(vec3 pos, float heat_gradient) {
         auto state = make<tensor>(list<int>{1, 6});
         state->flat(0) = pos.x() / 100.0f;
         state->flat(1) = pos.z() / 100.0f;
         state->flat(2) = heat_gradient;
         state->flat(3) = last_distance / 100.0f;
         state->flat(4) = randf(-0.1f, 0.1f);
         state->flat(5) = randf(-0.1f, 0.1f);
         return state;
     }
   
     int choose_action(g_ptr<tensor> state, float epsilon = 0.1f) {
         if(randf(0, 1) < epsilon) {
             return randi(0, 3);
         }
         
         auto h = state->forward(matmul1_pass);
         h = h->forward(add1_pass);
         h = h->forward(relu_pass);
         auto logits = h->forward(matmul2_pass);
         logits = logits->forward(add2_pass);
         
         // Argmax
         int best = 0;
         float best_val = logits->flat(0);
         for(int i = 1; i < 4; i++) {
             if(logits->flat(i) > best_val) {
                 best_val = logits->flat(i);
                 best = i;
             }
         }
         
         tensor::clear_graph(logits);
         return best;
     }
   
     void add_experience(const Experience& exp) {
         // Simple FIFO buffer - just append and truncate
         replay_buffer << exp;
         
         if(replay_buffer.length() > MAX_BUFFER_SIZE) {
             // Remove oldest experiences
             replay_buffer.removeAt(0);
         }
     }
 
     void learn_from_replay() {
         if(replay_buffer.length() < MIN_BUFFER_SIZE) return;
         
         // Random sampling from entire buffer
         list<int> sampled_indices;
         for(int i = 0; i < BATCH_SIZE; i++) {
             int idx = randi(0, replay_buffer.length() - 1);
             sampled_indices << idx;
         }
         
         // Train on batch
         for(int idx : sampled_indices) {
             auto exp = replay_buffer[idx];
             
             // Forward
             auto h = exp.state->forward(matmul1_pass);
             h = h->forward(add1_pass);
             h = h->forward(relu_pass);
             auto logits = h->forward(matmul2_pass);
             logits = logits->forward(add2_pass);
             
             // Create target
             auto target = make<tensor>(list<int>{1, 4});
             target->fill(0.0f);
             
             if(exp.reward > 0) {
                 target->at({0, exp.action}) = 1.0f;
             } else {
                 for(int j = 0; j < 4; j++) {
                     target->at({0, j}) = (j == exp.action) ? 0.0f : 0.33f;
                 }
             }
             
             // Loss & backprop
             loss_pass.op = SOFTMAX_CE;
             loss_pass.param = target;
             auto loss = logits->forward(loss_pass);
             
             loss->grad_[0] = 1.0f;
             loss->backward();
             
             tensor::clear_graph(loss);
         }
         
         // Update weights once per batch
         brain->step();
         brain->zero_grad();
     }
   
     void adaptive_learning_rate() {
         // Faster decay: 0.05 â†’ 0.001 over 50 goals
         float progress = std::min(times_reached_goal / 50.0f, 1.0f);
         float lr = 0.05f * (1.0f - progress) + 0.001f * progress;
         brain->set_lr(lr);
     }
};


int main() {
     // test_crumbs();
     // return 0;

     Window window = Window(win.x()/2, win.y()/2, "Golden 0.0.7");

     scene = make<Scene>(window,2);
     Data d = make_config(scene,K);
     scene->camera.toIso();
     scene->tickEnvironment(1100);

     scene->enableInstancing();

     if(false) {
          auto source_code = make<Font>(root()+"/Engine/assets/fonts/source_code_black.ttf",100);
          
          auto [train_imgs, train_labels] = ML::load_mnist(
          root()+"/Projects/FirML/assets/images/train-images-idx3-ubyte", 
          root()+"/Projects/FirML/assets/images/train-labels-idx1-ubyte", 
          -1
          );
          auto [test_imgs, test_labels] = ML::load_mnist(
          root()+"/Projects/FirML/assets/images/t10k-images-idx3-ubyte", 
          root()+"/Projects/FirML/assets/images/t10k-labels-idx1-ubyte", 
          -1
          );
          print("Loaded ", train_imgs->shape_[0], " training images");

          // Initialize weights and biases
          auto w1 = weight(784, 128, 0.1f);
          auto b1 = bias(128);
          auto w2 = weight(128, 10, 0.1f);
          auto b2 = bias(10);

          // Network definition - now using ADD instead of ADD_BIAS
          list<Pass> network = {
          {MATMUL, w1}, 
          {ADD, b1},      // Changed from ADD_BIAS to ADD
          {RELU},
          {MATMUL, w2}, 
          {ADD, b2}       // Changed from ADD_BIAS to ADD
          };
          list<g_ptr<tensor>> params = {w1, b1, w2, b2};

          Log::Line l;
          l.start();

          g_ptr<t_config> ctx = make<t_config>();
          ctx->epochs = 4;
          ctx->learning_rate = 0.64f;
          ctx->grad_clip = 1.0f;
          ctx->reduction = MEAN;
          ctx->batch_size = 64;

          train_network(
          train_imgs,      // Starting points
          train_labels,    // Targets for the network
          network,         // Nodes
          params,          // Tensors
          SOFTMAX_CE,      // Loss type
          ctx,
          1                // Logging interval (if 0, turns off logging)
          );

          double time = l.end();
          print("Took ", time/1000000, "ms");

          // Run forward pass on test data
          auto test_output = test_imgs;
          for(auto p : network) {
          test_output = test_output->forward(p);
          }

          // Calculate accuracy
          int correct = 0;
          int num_test = test_output->shape_[0];
          int num_classes = test_output->shape_[1];
          
          for(int i = 0; i < num_test; i++) {
          // Find predicted class (max value in row)
          int pred_class = 0;
          float max_val = test_output->at({i, 0});
          for(int j = 1; j < num_classes; j++) {
               if(test_output->at({i, j}) > max_val) {
                    max_val = test_output->at({i, j});
                    pred_class = j;
               }
          }
          
          // Find true class (which column is 1 in one-hot encoding)
          int true_class = 0;
          for(int j = 0; j < num_classes; j++) {
               if(test_labels->at({i, j}) == 1.0f) {
                    true_class = j;
                    break;
               }
          }
          
          if(pred_class == true_class) correct++;
          }

          float accuracy = 100.0f * correct / num_test;
          print("Test Accuracy: ", accuracy, "%");

          // Display random predictions
          list<int> indices = {
          randi(0, test_imgs->shape_[0] - 1), 
          randi(0, test_imgs->shape_[0] - 1), 
          randi(0, test_imgs->shape_[0] - 1)
          };

          list<g_ptr<Text>> twigs;
          for(int i = 0; i < 3; i++) {
          int idx = indices[i];
          
          // Display the image
          g_ptr<Quad> q = make<Quad>();
          scene->add(q);
          q->setTexture(ML::mnist_to_texture(test_imgs, idx));
          q->setPhysicsState(P_State::NONE);
          float pos_y = (float)i * 300.0f;
          vec2 pos(pos_y, 0.0f);
          q->setPosition(pos);
          vec2 scale(280, 280);
          q->scale(scale);

          // Get prediction for single image
          auto single_img = test_imgs->get_batch(idx, 1);
          auto output = single_img;
          for(auto p : network) {
               output = output->forward(p);
          }
          
          // Find predicted class (max output)
          int predicted = 0;
          for(int j = 1; j < num_classes; j++) {
               if(output->at({0, j}) > output->at({0, predicted})) {
                    predicted = j;
               }
          }
          
          // Display text showing prediction
          print("Image ", i, ": Predicted ", predicted);
          vec2 pos2(100.0f + pos_y, 300);
          g_ptr<Text> twig = make<Text>(source_code,scene);
          twigs << twig;
          twig->makeText(std::to_string(predicted),pos2);
          }
     }

     int amt = 1;
     float agents_per_unit = 0.3f;
     float total_area = amt / agents_per_unit;
     float side_length = std::sqrt(total_area);
     
     g_ptr<Physics> phys = make<Physics>(scene);
     float grid_size = std::max(100.0f,amt*0.05f);
     grid = make<NumGrid>(0.5f,grid_size);

     static bool use_grid = true; 

     auto terrain = make<Single>(makeBox({grid_size,0.1f,grid_size},{0.7f,0.4f,0.2f,1}));
     scene->add(terrain);
     terrain->setPhysicsState(P_State::NONE);
     terrain->setPosition({0,-0.2f,0});


     g_ptr<Model> a_model = make<Model>(MROOT+"agents/WhiskersLOD3.glb");
     g_ptr<Model> b_model = make<Model>(makeTestBox(1.0f));
     g_ptr<Model> c_model = make<Model>(makeTestBox(0.3f));
     g_ptr<Model> grass_model = make<Model>(MROOT+"products/grass.glb");
     g_ptr<Model> berry_model = make<Model>(MROOT+"products/berry.glb");
     g_ptr<Model> clover_model = make<Model>(MROOT+"products/clover.glb");
     g_ptr<Model> stone_model = make<Model>(MROOT+"products/stone.glb");
     c_model->setColor({0,0,1,1});
     a_model->localBounds.transform(0.6f);


     g_ptr<Model> red_model = make<Model>(makeBox(1,1,1,{1,0,0,1}));
     scene->define("red",Script<>("make_red",[red_model](ScriptContext& ctx){
          g_ptr<Single> q = make<Single>(red_model);
          scene->add(q);
          q->setPhysicsState(P_State::NONE);
          ctx.set<g_ptr<Object>>("toReturn",q);
     }));
     g_ptr<Model> green_model = make<Model>(makeBox(1,1,1,{0,1,0,1}));
     scene->define("green",Script<>("make_green",[green_model](ScriptContext& ctx){
          g_ptr<Single> q = make<Single>(green_model);
          scene->add(q);
          q->setPhysicsState(P_State::NONE);
          ctx.set<g_ptr<Object>>("toReturn",q);
     }));
     g_ptr<Model> blue_model = make<Model>(makeBox(1,1,1,{0,0,1,1}));
     scene->define("blue",Script<>("make_blue",[blue_model](ScriptContext& ctx){
          g_ptr<Single> q = make<Single>(blue_model);
          scene->add(q);
          q->setPhysicsState(P_State::NONE);
          ctx.set<g_ptr<Object>>("toReturn",q);
     }));
     g_ptr<Model> yellow_model = make<Model>(makeBox(1,1,1,{1,1,0,1}));
     scene->define("yellow",Script<>("make_yellow",[yellow_model](ScriptContext& ctx){
          g_ptr<Single> q = make<Single>(yellow_model);
          scene->add(q);
          q->setPhysicsState(P_State::NONE);
          ctx.set<g_ptr<Object>>("toReturn",q);
     }));
     g_ptr<Model> white_model = make<Model>(makeBox(1,1,1,{1,1,1,1}));
     scene->define("white",Script<>("make_white",[white_model](ScriptContext& ctx){
          g_ptr<Single> q = make<Single>(white_model);
          scene->add(q);
          q->setPhysicsState(P_State::NONE);
          ctx.set<g_ptr<Object>>("toReturn",q);
     }));
     g_ptr<Model> cyan_model = make<Model>(makeBox(1,1,1,{0,0.5,0.5,1}));
     scene->define("cyan",Script<>("make_cyan",[cyan_model](ScriptContext& ctx){
          g_ptr<Single> q = make<Single>(cyan_model);
          scene->add(q);
          q->setPhysicsState(P_State::NONE);
          ctx.set<g_ptr<Object>>("toReturn",q);
     }));
     g_ptr<Model> black_model = make<Model>(makeBox(1,1,1,{0,0,0,1}));
     scene->define("black",Script<>("make_black",[black_model](ScriptContext& ctx){
          g_ptr<Single> q = make<Single>(black_model);
          scene->add(q);
          q->setPhysicsState(P_State::NONE);
          ctx.set<g_ptr<Object>>("toReturn",q);
     }));

     map<int,crumb> crumbs;

     //I am very, very, very much going to remove the pointless script system in scene's pooling and simplify things.
     scene->define("agent",Script<>("make_agent",[a_model](ScriptContext& ctx){
          g_ptr<Single> q = make<Single>(a_model);
          scene->add(q);
          q->opt_idx_cache = addToGrid(q);
          q->opt_vec_3_3 = q->getPosition();
          q->joint = [q](){
                    q->updateTransform(false);
     
                    vec3 current_pos = q->getPosition();
                    float moved = current_pos.distance(q->opt_vec_3_3);
                    
                    // Only update grid if moved more than half a cell
                    if(moved > grid->cellSize * 0.5f) {
                    for(auto i : q->opt_idx_cache) {grid->cells[i].erase(q->ID);}
                         q->opt_idx_cache = grid->addToGrid(q->ID, q->getWorldBounds());
                         q->opt_vec_3_3 = current_pos;
                    }
               return false;
          };
          ctx.set<g_ptr<Object>>("toReturn",q);
     }));
     scene->define("crumb",Script<>("make_crumb",[c_model,phys](ScriptContext& ctx){
          g_ptr<Single> q = make<Single>(c_model);
          scene->add(q);
          q->scale(0.5f);
          q->setPhysicsState(P_State::NONE);
          q->opt_ints = list<int>(4,0);
          q->opt_floats = list<float>(2,0);
          q->opt_vec_3 = vec3(0,0,0);
          ctx.set<g_ptr<Object>>("toReturn",q);
     }));

     //Make path stones
     // for(int i=0;i<600;i++) {
     //      g_ptr<Single> box = make<Single>(b_model);
     //      scene->add(box);
     //      int f = i;
     //      box->dtype = "path";
     //      vec3 pos(randf(-100,100),0.5,randf(-100,100));
     //      box->setPosition(pos);
     //      box->setScale({1,0.5,1});
     //      box->setPhysicsState(P_State::GHOST);
     //      box->opt_ints << randi(1,10);
     //      box->opt_floats << 0.2f;
     // }


     //make_maze(b_model);
     int grass_count = (int)(grid_size * grid_size * 0.00f);
     for(int i = 0; i < grass_count; i++) {
         g_ptr<Single> box = make<Single>(grass_model);
         scene->add(box);
         box->dtype = "grass";
         float s = randf(3, 8);
         vec3 pos(randf(-grid_size/2, grid_size/2), 0, randf(-grid_size/2, grid_size/2));
         box->setPosition(pos);
         box->setScale({1.3, s, 1.3});
         box->setPhysicsState(P_State::PASSIVE);
         box->opt_ints << randi(1, 10);
         box->opt_floats << -1.0f;
         addToGrid(box);
         crumb mem;
         for(int r = 0; r < CRUMB_ROWS; r++) {
             for(int col = 0; col < 10; col++) {
                 mem.mat[r][col] = 0.0f;
             }
         }
         mem.mat[3][0] = randf(1.0f,1.04f); //Satiety
         mem.mat[3][1] = randf(0.2f,0.6f); //Shelter
         mem.form = box;
         crumbs.put(box->ID,mem);
     }

     // g_ptr<Single> clover = make<Single>(clover_model);
     // scene->add(clover);
     // clover->dtype = "clover";
     // clover->setScale({1,1.2,1});
     // clover->setPosition({0,0,0});
     // clover->setPhysicsState(P_State::PASSIVE);
     // addToGrid(clover);
     // crumb clover_crumb;
     // clover_crumb.mat[3][0] = 0.5f; //Satiety
     // clover_crumb.mat[3][1] = 1.3f; //Shelter
     // clover_crumb.form = clover;
     // crumbs.put(clover->ID,clover_crumb);

     list<g_ptr<Single>> agents;
     list<vec3> goals;
     list<list<g_ptr<Single>>> debug;
     list<g_ptr<crumb_manager>> crumb_managers;

     g_ptr<Thread> run_thread = make<Thread>();
     g_ptr<Thread> update_thread = make<Thread>();
     
     // struct ObservationBatch {
     //      vec3 agent_pos;
     //      int agent_id;
     //      list<std::pair<float,int>> observed_objects;
     //      g_ptr<crumb_manager> memory;
     // };
     // list<ObservationBatch> batch;

     int width = (int)std::sqrt(amt);
     float spacing = side_length / width;


     list<g_ptr<HotColdLearner>> learner; 
     struct LearningStats {
          list<g_ptr<Single>> debug_lines;
          float total_distance = 0;
          float total_reward = 0;
          int frame_count = 0;
          
          void clear_debug() {
              for(auto d : debug_lines) {
                  scene->recycle(d);
              }
              debug_lines.clear();
          }
      };
      LearningStats stats;

     for(int i=0;i<amt;i++) {
          g_ptr<Single> agent = scene->create<Single>("agent");
          int f = i;
          int row = i / width;
          int col = i % width;
          vec3 base_pos(
              (col - width/2) * spacing,
              0,
              (row - width/2) * spacing
          );
          // base_pos.addZ(-35);
          // base_pos.addX(-22);
          vec3 jitter(randf(-spacing*0.3f, spacing*0.3f), 0, randf(-spacing*0.3f, spacing*0.3f));
          agent->setPosition(base_pos + jitter);
          agent->setPhysicsState(P_State::FREE);
          agent->opt_ints << randi(1,10); // [0]
          agent->opt_ints << i; // [1] = ITR id
          agent->opt_ints << 0; // [2] = Accumulator
          agent->opt_ints << 0; // [3] = Accumulator 2
          agent->opt_ints << 0; // [4] = Accumulator 3
          agent->opt_ints << 0; // [5] = Accumulator 4
          agent->opt_ints << 0; // [6] = Accumulator 5
          agent->opt_ints << 0; // [7] = Progress
          agent->opt_ints << 1; // [8] = Nav strategy
          agent->opt_floats << -0.4f; // [0] = attraction
          agent->opt_floats << randf(4,6); // [1] = speed
          agent->opt_floats << 1.0f; // [2] = goal focus
          agent->opt_vec3_2 = vec3(0,0,0); //Last position
          agents << agent;

          g_ptr<Single> marker = scene->create<Single>("crumb");
          // vec3 possible_pos = vec3(
          //      randf(-side_length/2, side_length/2), 
          //      0, 
          //      randf(-side_length/2, side_length/2)
          // );
          vec3 possible_pos = vec3(-22,0,-35);
          int depth = 0;
          while(!grid->getCell(possible_pos).empty()&&depth<50) {
               possible_pos = vec3(randf(-5,5), 0, randf(-5,5));
               depth++;
          }
          marker->setPosition(possible_pos);
          marker->setPhysicsState(P_State::NONE);
          goals << marker->getPosition();

          g_ptr<crumb_manager> memory = make<crumb_manager>();
          memory->agent_id = agent->ID;
          crumb mem;
          for(int r = 0; r < CRUMB_ROWS; r++) {
               for(int col = 0; col < 10; col++) {
                    mem.mat[r][col] = 0.0f;
               }
          }
          mem.mat[0][0] = 1.0f; //Distance saliance factor
          mem.mat[0][1] = 0.8f; //Navigation focus
          mem.mat[0][2] = 1.0f; //Salience impactor
          mem.mat[3][0] = randf(0.1f,0.3f); //Satiety
          mem.mat[3][1] = randf(0.2f,0.6f); //Shelter
          mem.mat[13][0] = randf(1.0f,1.8f); //Hunger
          mem.mat[13][1] = randf(0.1f,0.2f); //Tierdness
          mem.form = agent;
          crumbs.put(agent->ID,mem);

          crumb mem_root;
          g_ptr<Single> root_form = scene->create<Single>("crumb");
          root_form->setPosition(base_pos);
          mem_root.form = root_form;
          memory->meta_root->archetype = mem_root;
          memory->id_to_node.put(root_form->ID,memory->meta_root.getPtr());
          memory->current_state = mem;
                         
          crumb_managers << memory;

          grid->make_seethru(agent->ID);

           // In main, add to each agent:
          agent->opt_ptr = make<HotColdLearner>();  // Assuming you have g_ptr slot
          auto learner = (HotColdLearner*)agent->opt_ptr.getPtr();
          learner->init(agent->getPosition(), vec3(randf(-50, 50), 0, randf(-50, 50)));

          float agent_hue = (float(i) / float(amt)) * 360.0f;  



           agent->physicsJoint = [agent, &stats, i]() {
               auto learner = (HotColdLearner*)agent->opt_ptr.getPtr();
               int id = i;
    
               vec3 pos = agent->getPosition();
               float curr_dist = pos.distance(learner->hidden_target);
               float heat_gradient = learner->last_distance - curr_dist;
               
               // === VISUAL FEEDBACK ===
               if(id % 10 == 0) {
                   auto line = draw_line(pos, learner->hidden_target, "cyan", 0.5f);
                   stats.debug_lines << line;
               }
               

               
               // === CHECK FOR SUCCESS ===
               if(curr_dist < 5.0f) {
                   learner->times_reached_goal++;
                   print("ðŸŽ¯ Mouse ", id, " reached goal! (attempt #", learner->times_reached_goal, 
                         " after ", learner->steps_taken, " steps, cum_reward=", learner->cumulative_reward,
                         ", buffer_size=", learner->replay_buffer.length(), ")");
                   
                   // CURRICULUM: Start nearby, gradually increase difficulty
                   float reset_radius = 20.0f + (learner->times_reached_goal * 1.5f);
                   reset_radius = std::min(reset_radius, 100.0f);
                   
                   vec3 offset(randf(-reset_radius, reset_radius), 0, 
                               randf(-reset_radius, reset_radius));
                   learner->hidden_target = pos + offset;
                   
                   // Every 25 goals, force a far reset for diversity
                   if(learner->times_reached_goal % 25 == 0) {
                       learner->hidden_target = vec3(randf(-100, 100), 0, randf(-100, 100));
                       print("ðŸ”„ Mouse ", id, " exploration reset (far spawn)");
                   }
                   
                   learner->last_distance = pos.distance(learner->hidden_target);
                   learner->steps_taken = 0;
                   learner->cumulative_reward = 0;
                   
                   // Adapt learning rate
                   learner->adaptive_learning_rate();
               }
               
               // === LEARNING ===
               auto state = learner->encode_state(pos, heat_gradient);
               
               // Epsilon decay: 0.3 â†’ 0.05
               float epsilon = 0.05f + 0.25f * exp(-stats.frame_count / 2000.0f);
               int action = learner->choose_action(state, epsilon);
               
               // Apply action (DISCRETE STEPS)
               vec3 direction(0, 0, 0);
               float step_size = 2.0f;
               switch(action) {
                   case 0: direction = vec3(0, 0, -step_size); break;
                   case 1: direction = vec3(step_size, 0, 0); break;
                   case 2: direction = vec3(0, 0, step_size); break;
                   case 3: direction = vec3(-step_size, 0, 0); break;
               }
               
               agent->setPosition(pos + direction);
               agent->setLinearVelocity(vec3(0, 0, 0));
               
               // Compute reward
               float reward = heat_gradient / step_size;
               reward = std::clamp(reward, -1.0f, 1.0f);
               
               // Track metrics
               learner->cumulative_reward += reward;
               learner->steps_taken++;
               learner->best_distance = std::min(learner->best_distance, curr_dist);
               
               // Store experience
               HotColdLearner::Experience exp;
               exp.state = state; exp.action = action; exp.reward = reward;
               learner->add_experience(exp);
               // Learn from replay every 5 steps
               if(learner->steps_taken % 5 == 0) {
                    learner->learn_from_replay();
               }
               
               // Update for next iteration
               learner->last_distance = curr_dist;
               
               // === AGGREGATE STATS ===
               stats.total_distance += curr_dist;
               stats.total_reward += reward;
               
               return true;
           };
          // agent->physicsJoint = [agent, memory, marker, update_thread, &crumb_managers, &goals, &agents, &crumbs, &debug, phys, side_length]() {
          //      #if GTIMERS
          //      Log::Line overall;
          //      Log::Line l;
          //      list<double>& timers = agent->timers;
          //      list<std::string>& timer_labels = agent->timer_labels;
          //      timers.clear(); timer_labels.clear();
          //      overall.start();
          //      agent->opt_ints[4] = 0;
          //      // agent->opt_ints[5] = 0;
          //      #endif
          //      //Always setup getters for sketchpad properties because chances are they'll change later
          //      //Plus it helps with clarity to name them
          //      int id = agent->opt_ints[1];
          //      list<g_ptr<Single>>& my_debug = debug[id];
          //      g_ptr<Single> goal_crumb = marker;
          //      int& spin_accum = agent->opt_ints[2];
          //      int& on_frame = agent->opt_ints[3];
          //      float& goal_focus = agent->opt_floats[2];
          //      int& accum5 = agent->opt_ints[5];
          //      int& frames_since_progress = agent->opt_ints[7];
          //      int& nav_strat = agent->opt_ints[8];
          //      float navigation_focus = memory->navigation_focus();
          //      //The path can always be grabbed, and used to install directions in situations beyond A*, it's the only continous movment method that isn't velocity depentent.
          //      list<int>& path = agent->opt_idx_cache_2;
          //      //This is just for testing
          //      vec3 goal = goals[id];  //goal_crumb->getPosition();

          //      float moved_recently = agent->getPosition().distance(agent->opt_vec3_2);
          //      if(moved_recently > 2.0f) {
          //           agent->opt_vec3_2 = agent->getPosition();
          //           frames_since_progress = 0;
          //      } else {
          //           frames_since_progress++;
          //      }

          //      // int thrash_interval = 15;
          //      // if(on_frame % thrash_interval == id % thrash_interval) {
          //      //      #if GTIMERS
          //      //      l.start();
          //      //      #endif

          //      //      list<vec3> directions = memory->come_up_with_a_path(accum5);

          //      //      #if GTIMERS
          //      //      timers << l.end(); timer_labels << "come_up_with_a_path";
          //      //      #endif
          //      // }

          //      if(agent->distance(marker) <= 10.0f) {
          //           goal = marker->getPosition();
          //      }

          //      // if(goal_focus>0.7f && agent->distance(goal) <= 10.0f) {
          //      //      // agent->setLinearVelocity({0,0,0});
          //      //      if(goal==marker->getPosition()) {
          //      //           marker->setPosition(agent->getPosition().addZ(-40));
          //      //           memory->current_state.mat[3][0] = 2.0f;
          //      //           memory->current_state.mat[0][1] = 0.0f;

          //      //           #if GTIMERS
          //      //           l.start();
          //      //           #endif

          //      //           list<vec3> directions = memory->come_up_with_a_path(accum5);

          //      //           #if GTIMERS
          //      //           timers << l.end(); timer_labels << "come_up_with_a_path";
          //      //           #endif
          //      //           // print("Has seen a clover? ",agent->opt_ints[6]==1?"Yes":"No");
          //      //           if(!directions.empty()) {
          //      //                print("Came up with: ",directions.length()," directions");
          //      //                directions.reverse();
          //      //                goal = directions.last();
          //      //                goal_focus = 1.0f;
          //      //                for(auto d : directions) {
          //      //                     path << grid->toIndex(d);
          //      //                }
          //      //                print("CURRENT TARGET: ",grid->indexToLoc(path[0]).to_string());
          //      //                memory->clear_debug();
          //      //           } else {
          //      //                print("Failed to create directions");
          //      //                goal_focus = 0.0f;
          //      //           }
          //      //           bool seen_berry = false;
          //      //           for(auto e : memory->id_to_node.entrySet()) {
          //      //                if(scene->singles[e.key]->dtype=="berry") 
          //      //                     seen_berry = true;
          //      //           }
          //      //           print("has ",seen_berry?"":"not ","seen berry");

          //      //      } else {
          //      //           goals[id] = marker->getPosition();
          //      //           goal_focus = 0.9f;
          //      //      }
          //      // }

          //      float desired_speed = agent->opt_floats[1];  
          //      on_frame++; 
          //      bool enable_astar = false;
          //      int pathing_interval = 15; 
          //      //A* Unit
          //           if(enable_astar && (on_frame % (pathing_interval*20) == id % (pathing_interval*20)  || path.empty())) {
          //                path = grid->findPath(
          //                     grid->toIndex(agent->getPosition()),
          //                     grid->toIndex(goal),
          //                     [agent](int idx) {
          //                          if(grid->cells[idx].empty()) return true;
          //                          if(grid->cells[idx].length() == 1 && grid->cells[idx].has(agent->ID)) return true;
          //                          return false; // Occupied by walls or other agents
          //                     }
          //                );
          //                if(path.empty()) {
          //                     // print("UNABLE TO FIND A PATH!");
          //                     // vec3 new_goal = vec3(randf(-100,100),0,randf(-100,100));
          //                     // scene->reactivate(goal_crumb);
          //                     // crumbs[id][0]->setPosition(new_goal);
          //                     return true;
          //                }
          //           }

          //      vec3 goal_loc = agent->opt_vec_3_4;

          //      if(!path.empty()) {
          //           #if GTIMERS
          //           l.start();
          //           #endif

          //           vec3 waypoint = grid->indexToLoc(path[0]);
          //           float waypoint_dist = agent->getPosition().distance(waypoint);

          //           if(frames_since_progress>=30) {
          //                // list<int> new_path = grid->findPath(
          //                //      grid->toIndex(agent->getPosition()),
          //                //      grid->toIndex(waypoint),
          //                //      [agent](int idx) {
          //                //           if(grid->empty(idx)) return true;
          //                //           if(grid->has_only(idx,agent->ID)) return true;
          //                //           return false; // Occupied by walls or other agents
          //                //      }
          //                // );
          //                // print("Came up with a new path with: ",new_path.length()," nodes");
          //                // path << new_path;
          //                agent->setPosition(waypoint); //Cheating for now so I can focus on other things
          //           } 
          //           if(waypoint_dist < grid->cellSize) {
          //                path.removeAt(0);
          //                if(!path.empty()) {
          //                     waypoint = grid->indexToLoc(path[0]);
          //                } else {
          //                     // print("PATH COMPLETE!!");
          //                }
          //           }
          //           vec3 direction = (waypoint - agent->getPosition()).normalized().nY();
          //           agent->faceTo(agent->getPosition() + direction);
          //           agent->setLinearVelocity(direction * desired_speed);

          //           #if GTIMERS
          //           timers << l.end(); timer_labels << "navigate_path";
          //           #endif
          //      }
          //      else if(on_frame % pathing_interval == id % pathing_interval) {
          //           vec3 current_velocity = agent->getVelocity().position;
          //           float actual_speed = current_velocity.length();
          //           float speed_ratio = actual_speed / std::max(desired_speed, 0.1f);
          //           #if GTIMERS
          //           l.start();
          //           #endif
                    
          //           // Tunable parameters
          //           int num_rays = 24; 
          //           float ray_distance = 30.0f;
          //           float cone_width = 235.0f; 
                    
          //           // Get goal direction for biasing
          //           vec3 to_goal = agent->getPosition().direction(goal).nY();
          //           float goal_distance = agent->getPosition().distance(goal);
          //           vec3 forward =  agent->facing().nY(); //to_goal.length() > 0.01f ? to_goal.normalized() : agent->facing().nY();
          //           vec3 right = vec3(forward.z(), 0, -forward.x()); // Perpendicular
                                        
          //           // Cast rays in a forward-biased cone
          //           float best_openness = 0.0f;
          //           vec3 best_direction = forward;
                    
          //           float start_angle = -cone_width / 2.0f;
          //           float angle_step = cone_width / (num_rays - 1);

          //           float best_goal_alignment = -1.0f;
          //           float best_aligned_clearance = 0.0f;
                    
          //           list<std::pair<float,int>> observed_objects;
          //           list<g_ptr<Single>> new_crumbs;
                
          //           #if VISPATHS
          //           list<g_ptr<Single>> raycast_debug;
          //           #endif
                    
          //           list<float> ray_distances;

          //           float left_clearance = 0.0f;
          //           float right_clearance = 0.0f;
          //           float left_count = 0.0f;
          //           float right_count = 0.0f;

          //           #if GTIMERS
          //           timers << l.end(); timer_labels << "raycast_setup"; l.start();
          //           #endif

          //           for(int i = 0; i < num_rays; i++) {
          //               float angle_deg = start_angle + i * angle_step;
          //               float angle_rad = angle_deg * 3.14159f / 180.0f;
                        
          //               vec3 ray_dir = (forward * cos(angle_rad) + right * sin(angle_rad)).normalized();
                        
          //               std::pair<float,int> hit_info = grid->raycast(
          //                   agent->getPosition(),
          //                   ray_dir,
          //                   ray_distance,
          //                   agent->ID
          //               );
          //               float hit_dist = hit_info.first;
          //               int hit_cell = hit_info.second;
          //               ray_distances << hit_dist;

          //               if(angle_deg < 0) {
          //                     left_clearance += hit_dist;
          //                     left_count++;
          //                } else {
          //                     right_clearance += hit_dist;
          //                     right_count++;
          //                }
                        
          //               #if VISPATHS
          //               vec3 ray_end = agent->getPosition() + ray_dir * hit_dist;
          //               raycast_debug << draw_line(agent->getPosition(), ray_end, "white", 0.5f);
          //               #endif
                        
          //               if(std::abs(angle_deg) < 90.0f) {  // Within Â±90Â° of forward
          //                     if(hit_dist > best_openness) {
          //                          best_openness = hit_dist;
          //                          best_direction = ray_dir;
          //                     }
          //                     float goal_alignment = ray_dir.dot(to_goal.normalized());
          //                     if(goal_alignment > best_goal_alignment) {
          //                         best_goal_alignment = goal_alignment;
          //                         best_aligned_clearance = hit_dist;
          //                     }
          //                }

          //               bool curr_hit = (hit_cell >= 0 && !grid->cells[hit_cell].empty());
          //               if(curr_hit) {
          //                   for(int obj_id : grid->cells[hit_cell]) {
          //                       if(obj_id != agent->ID && 
          //                          !observed_objects.has({hit_dist, obj_id})) {
          //                           observed_objects << std::make_pair(hit_dist, obj_id);
          //                       }
          //                   }
          //               }
          //           }
                    
          //           #if GTIMERS
          //           timers << l.end(); timer_labels << "raycast_sampling"; l.start();
          //           #endif

          //           int gap_start = -1;
          //           list<vec3> gaps;
          //           int rayspace = grid->cellSize * 5.0f;
          //           //printnl("POS: ",agent->getPosition().to_string(),", RAYS: [");
          //           for(int i = 1; i < num_rays; i++) {
          //                float depth_jump = ray_distances[i] - ray_distances[i-1];
          //                // if(i!=1) printnl(", ");
          //                // printnl(ray_distances[i],"^",depth_jump);
                         
          //                if(gap_start < 0 && depth_jump > rayspace) {
          //                     //printnl(" ->");
          //                     //Entering a gap
          //                     gap_start = i;
          //                } else if(gap_start >= 0 && depth_jump < -grid->cellSize * 2.0f) {
          //                     int left_edge_idx = gap_start - 1;
          //                     float left_angle_deg = start_angle + left_edge_idx * angle_step;
          //                     float left_angle_rad = left_angle_deg * 3.14159f / 180.0f;
          //                     vec3 left_ray_dir = (forward * cos(left_angle_rad) + right * sin(left_angle_rad)).normalized();
          //                     vec3 point_A = agent->getPosition() + left_ray_dir * ray_distances[left_edge_idx];
          //                     int right_edge_idx = i;
          //                     float right_angle_deg = start_angle + right_edge_idx * angle_step;
          //                     float right_angle_rad = right_angle_deg * 3.14159f / 180.0f;
          //                     vec3 right_ray_dir = (forward * cos(right_angle_rad) + right * sin(right_angle_rad)).normalized();
          //                     vec3 point_B = agent->getPosition() + right_ray_dir * ray_distances[right_edge_idx];
                              
          //                     vec3 gap_pos = (point_A + point_B) * 0.5f;
          //                     if(!grid->empty(gap_pos)) continue;
          //                     //printnl(" GAP(",gap_pos.to_string(),")");
                              
          //                     gaps << gap_pos;

          //                     #if VISPATHS
          //                          auto marker = scene->create<Single>("white");
          //                          marker->setPosition(gap_pos.addY(1.0f));
          //                          marker->setScale({0.5f,1,0.5f});
          //                          raycast_debug << marker;
          //                     #endif

          //                     gap_start = -1;
          //                 }
          //           }
          //           //printnl("]\n");

          //           // Cycle through strategies: 0=none, 1=left, 2=forward, 3=right
          //           int gap_strategy = 1;
          //           vec3 gap_bias(0, 0, 0);
          //           float gap_curiosity = 1.0f;
          //           vec3 best_gap(0, 0, 0);
          //           float best_score = -1000.0f;

          //           for(auto g : gaps) {
          //                vec3 to_gap = (g - agent->getPosition()).normalized();
          //                float forward_align = to_gap.dot(forward);
          //                float right_align = to_gap.dot(right);
                         
          //                float score = 0.0f;
          //                switch(gap_strategy) {
          //                     case 0: continue; // none - skip gaps entirely
          //                     case 1: score = -right_align; break; // left (negative right)
          //                     case 2: score = forward_align; break; // forward
          //                     case 3: score = right_align; break; // right
          //                }
                         
          //                if(score > best_score) {
          //                     best_score = score;
          //                     best_gap = to_gap;
          //                }

          //                g_ptr<CategoryNode> node = memory->closest_visible_node(g,{},{"gap"});
          //                if(node) {
          //                     //memory->decrease_novelty(memory->physics_attention[found_id]);
          //                     observed_objects << std::make_pair(5.0f,node->getID());
          //                } else { //If we haven't seen this junction before
          //                     auto marker = scene->create<Single>("crumb");
          //                     marker->setPosition(g);
          //                     marker->hide();
          //                     marker->dtype = "gap";
                              
          //                     crumb gap;
          //                     gap.form = marker;
          //                     gap.mat[0][1] = 8.0f; //Make it quite novel                             
          //                     crumbs.put(marker->ID, gap);
          //                     observed_objects << std::make_pair(5.0f, marker->ID);
          //                     new_crumbs << marker;
          //                }
          //           }

          //            #if GTIMERS
          //            timers << l.end(); timer_labels << "raycast_gap_sample"; l.start();
          //            #endif
                                
          //           float gap_bias_strength = 10.6f;
          //           float goal_bias_strength = 0.6f;
          //           float wall_bias_strength = 0.4f;

          //           if(best_score > 0.0f) {
          //                gap_bias = best_gap * gap_bias_strength; // Weight for gap bias
          //           }

          //           // Decide movement: beeline if well-aligned and clear, otherwise use best scored direction
          //           float beeline_threshold = 0.95f * goal_focus; // Scales with goal focus
          //           bool can_beeline = (best_goal_alignment > beeline_threshold && 
          //                               best_aligned_clearance >= goal_distance);
                    
          //           left_clearance /= left_count;
          //           right_clearance /= right_count;
          //           vec3 wall_bias = right * ((right_clearance - left_clearance) / ray_distance) * wall_bias_strength;
                    
          //           float wall_proximity = 1.0f / (std::min(left_clearance, right_clearance) + 1.0f);
          //           float goal_weight = std::lerp(0.5f, 0.0f, wall_proximity);
          //           vec3 goal_bias = to_goal * goal_weight * goal_bias_strength;
                    
          //           //print("BEST DIR: ",best_direction.to_string(),", WALL_BIAS: ",wall_bias.to_string(),", GOAL_BIAS: ",goal_bias.to_string(),", GAP_BIAS: ",gap_bias.to_string());
          //           vec3 environmental_force = can_beeline ? 
          //                to_goal.normalized() : 
          //                (best_direction + wall_bias + goal_bias + gap_bias).normalized();
          //           // print("ENVIRO FORCE: ",environmental_force.to_string());
          //           //     (best_openness > 1.0f ? best_direction : vec3(randf(-1, 1), 0, randf(-1, 1)));
                
          //           agent->opt_ints[4] += observed_objects.length();
                
          //           vec3 familiarity_vector(0, 0, 0);
          //           int familiar_count = 0;
          //           g_ptr<CategoryNode> most_relevant = nullptr;
          //           float highest_relevency = 0.0f;
          //           for(auto info : observed_objects) {
          //                #if GTIMERS
          //                l.start();
          //                #endif
                
          //                int obj_id = info.second;
          //                //print("Crumbs has this key: ",obj_id,"? ",crumbs.hasKey(obj_id)?"Yes":"No");
          //                crumb obj_crumb = crumbs[obj_id]; //Make a copy
          //                crumb* obs = &obj_crumb;
          //                g_ptr<Single> single = scene->singles[obj_id];
          //                if(single->dtype=="wall") {
          //                     // if(obs->mat[0][1]==0.0f) {
          //                     //      obs->mat[0][1] = 3.0f; //Make walls novel
          //                     // } 
          //                     if(obs->mat[0][2]==0.0f) {
          //                          obs->mat[0][2] = -100.0f; //Make walls unattractive
          //                     } 
          //                }

          //                obs->form = single;
          //                float dist_to_obj = info.first;
                
          //                #if GTIMERS
          //                timers << l.end(); timer_labels << "observe_value_init"; l.start();
          //                #endif
                    
          //                g_ptr<CategoryNode> seen_before = memory->has_seen_before_cheat(*obs);

          //                #if GTIMERS
          //                timers << l.end(); timer_labels << "has_seen_before"; l.start();
          //                #endif

          //                if(seen_before != nullptr) {
          //                     obs = &seen_before->archetype;
          //                     memory->decrease_novelty(seen_before);
          //                     //print("I've seen this before... novelty is now ",obj_crumb->mat[0][1]);
          //                     float novelty = seen_before->archetype.mat[0][1];
          //                     if(novelty < 3.0f) { // Familiar
          //                         vec3 to_familiar = (obs->form->getPosition() - agent->getPosition()).normalized();
          //                         float familiarity_weight = (3.0f - novelty);
                                  
          //                         familiarity_vector = familiarity_vector + (to_familiar * familiarity_weight);
          //                         familiar_count++;
          //                     }
          //                } 

          //                #if GTIMERS
          //                timers << l.end(); timer_labels << "seen_before_resolve"; l.start();
          //                #endif

          //                obs->mat[0][0] = 1.0f / (info.first + 1.0f); // Temporary distance for salience
          //                float salience = memory->salience(*obs);
          //                float relevance = memory->relevance(*obs, salience);
          //                //print("Dist: ",1.0f / (info.first + 1.0f)," actual_dist: ",info.first," Sal: ",salience," Rel: ",relevance);
          //                obs->mat[0][0] = 0.0f; // Clear temporary distance (don't persist)
          //                #if GTIMERS
          //                timers << l.end(); timer_labels << "sal_rel_calcs"; l.start();
          //                #endif
          //                if(relevance>0.3f) {
          //                     //Remove the gap crumb if we used it
          //                     int found_idx = new_crumbs.find(single);
          //                     if(found_idx!=-1) {new_crumbs.removeAt(found_idx);}
          //                     g_ptr<CategoryNode> node = nullptr;
          //                     if(seen_before == nullptr) {
          //                          //print("Look! Something new!");
          //                          //obs->mat[0][1] = 3.0f; //Novelty
          //                          //node = memory->observe(*obs,single);
          //                     } else {
          //                          node = seen_before;
          //                        //  memory->push_attention_head(seen_before);
          //                     }

          //                     if(relevance>highest_relevency) {
          //                          highest_relevency = relevance;
          //                          most_relevant = node;
          //                     }

          //                     #if VISPATHS
          //                          struct ray_debug {
          //                               vec3 from;
          //                               vec3 to;
          //                               bool hit = false;
          //                          };

          //                          vec3 pos = single->getPosition();
          //                          int best = memory->physics_attention.length()-1;
          //                          float best_dist = 100.0f;
          //                          list<ray_debug> visrays;
          //                          for(int j = 0; j<memory->physics_attention.length();j++) {
          //                               g_ptr<CategoryNode> n = memory->physics_attention[j];
          //                               float dist = n->getPosition().distance(pos);
          //                               vec3 dir = n->getPosition().direction(pos);
          //                               auto cast = grid->raycast(n->getPosition(),dir,dist,{agent->ID,n->getID(),single->ID});
          //                               if(cast.second==-1&&dist<best_dist&&n->getID()!=single->ID) {
          //                                    best_dist = dist;
          //                                    best = j;
          //                               }
          //                               vec3 ray_end = n->getPosition() + dir * cast.first;
          //                               visrays << ray_debug{n->getPosition(),ray_end,cast.second!=-1};
          //                               // bool cansee = grid->can_see(n->getPosition(),pos,{id,n->getID()});
          //                          }
          //                          for(int j = 0; j<memory->physics_attention.length();j++) {
          //                               g_ptr<CategoryNode> n = memory->physics_attention[j];
          //                               ray_debug d = visrays[j];
          //                               raycast_debug << draw_line(d.from, d.to, j==best?"black":d.hit?"red":"cyan", j==best?2.8f:0.5f);
          //                          }
          //                     #endif

          //                     if(relevance>0.9f) {
          //                          //print("I wanna go there");
          //                          goals[id] = vec3(scene->transforms[obj_id][3]);
          //                          goal_focus = 1.0f; // Set high goal focus
          //                     }
          //                } 


          //                #if GTIMERS
          //                timers << l.end(); timer_labels << "observe_resolution";
          //                #endif
          //           }
          //           if(most_relevant) {
          //                memory->push_attention_head(most_relevant);
          //           }
          //           if(familiar_count > 0) {
          //                familiarity_vector = familiarity_vector.normalized(); // Average direction
                         
          //                // Gentle override strength based on focus
          //                float repulsion_blend = navigation_focus * goal_focus * 0.3f; // Tune this weight
                         
          //                // Blend away from familiarity into the environmental force
          //                environmental_force = (environmental_force * (1.0f - repulsion_blend)) + 
          //                                      (familiarity_vector * -repulsion_blend);
          //                environmental_force = environmental_force.normalized();
          //            }

          //           for(auto r : new_crumbs) {
          //                scene->recycle(r);
          //           }
          //           #if VISPATHS
          //                memory->visualize_registry(memory->physics_attention.last());
          //                memory->debug << raycast_debug;
          //           #endif
                    
          //           #if GTIMERS
          //           timers << l.end(); timer_labels << "raycast_postprocess"; l.start();
          //           #endif
                
          //           if(environmental_force.length() > 0.01f) {
          //                environmental_force = environmental_force.normalized();
                         
          //                // Blend with momentum (if we're already moving)
          //                vec3 final_direction;
          //                if(current_velocity.length() > 0.1f) {
          //                     final_direction = (current_velocity.normalized() * 0.2f + environmental_force * 0.8f).normalized();
          //                } else {
          //                     final_direction = environmental_force;
          //                }
                         
          //                vec3 velocity = final_direction * desired_speed;
          //                agent->faceTo(agent->getPosition() + velocity);
          //                agent->setLinearVelocity(velocity);
          //           }
          //           #if GTIMERS
          //           timers << l.end(); timer_labels << "velocity_application";
          //           #endif
          //       }

          //      #if GTIMERS
          //      timers << overall.end(); timer_labels << "overall";
          //      #endif
               
          //      return true;
          // };


          agent->threadUpdate = [agent, i, memory, update_thread, &agents, &crumb_managers, &crumbs](){
               // #if GTIMERS
               //      Log::Line overall, l;
               //      list<double>& timers = agent->timers2;
               //      list<std::string>& timer_labels = agent->timer_labels2;
               //      timers.clear(); timer_labels.clear();
               //      overall.start();
               //      l.start();
               //      // agent->opt_ints[5] = 0;
               // #endif
               
               // static thread_local int on_frame = 0;


               // int id = agent->opt_ints[1];
               // g_ptr<crumb_manager> memory = crumb_managers[id];
               // on_frame++; 
               


               // #if GTIMERS
               // timers << l.end(); timer_labels << "value setup"; l.start();
               // #endif

     
               // #if GTIMERS
               // timers << l.end(); timer_labels << "thread flush";
               // #endif

               // int eval_interval = 600;
               // if(on_frame % eval_interval == id % eval_interval) {
               
               // }

               // int recategorize_interval = 600;
               // if(on_frame % recategorize_interval == id % recategorize_interval) {
               //      #if GTIMERS
               //      l.start();
               //      #endif

                    
               // }
               
               // #if GTIMERS
               // timers << overall.end(); timer_labels << "overall";
               // #endif
          };
     }
     vec3 cam_pos(0, side_length * 0.8f, side_length * 0.8f);
     scene->camera.setPosition(cam_pos);
     scene->camera.setTarget(vec3(0, 0, 0));

     //Reward for the agent completing their goal
     g_ptr<Single> berry = make<Single>(berry_model);
     scene->add(berry);
     berry->dtype = "berry";
     berry->setPosition(agents[0]->getPosition()+agents[0]->facing()*2.0f);
     berry->setPhysicsState(P_State::PASSIVE);
     addToGrid(berry);
     // grid->make_seethru(berry->ID);
     crumb berry_crumb;
     berry_crumb.mat[3][0] = 1.3f; //Satiety
     berry_crumb.mat[3][1] = 0.5f; //Shelter
     berry_crumb.form = berry;
     crumbs.put(berry->ID,berry_crumb);
     //crumb_managers[0]->observe(berry_crumb,berry);

     // for(auto memory : crumb_managers) {
     //      for(int c = 0; c < 10; c++) {
     //           crumb mem;
               
     //           // Fill with random data for benchmark
     //           for(int r = 0; r < CRUMB_ROWS; r++) {
     //           for(int col = 0; col < 10; col++) {
     //                mem.mat[r][col] = randf(-1, 1);
     //           }
     //           }
               
     //           // Embed position in first 3 rows, column 0
     //           mem.mat[0][0] = randf(-side_length/2, side_length/2);
     //           mem.mat[1][0] = 0.0f;
     //           mem.mat[2][0] = randf(-side_length/2, side_length/2);
               
     //           auto form = scene->create<Single>("crumb");
     //           mem.form = form;
     //           form->setPosition({1000,100,100});
     //           scene->deactivate(form);
     //           // memory->addCrumb(mem);
     //           crumbs.put(form->ID,mem);
     //      }
     // }

     // g_ptr<Single> test_origin = make<Single>(make<Model>(makeTestBox(1.0f)));
     // scene->add(test_origin);
     // test_origin->setPosition(vec3(0, 0.5, 0));
     // test_origin->setPhysicsState(P_State::NONE);
     // test_origin->setColor({1, 0, 0, 1}); // Red marker

     // list<g_ptr<Single>> ray_markers;
     // for(int i = 0; i < 10000; i++) {
     //      g_ptr<Single> marker = make<Single>(c_model);
     //      scene->add(marker);
     //      marker->setPhysicsState(P_State::NONE);
     //      marker->scale({0.5f,12,0.5f});
     //      ray_markers << marker;
     //      scene->deactivate(marker);
     // }

     // list<g_ptr<Single>> walls;
     // int on_wall = 0;
     // for(int i=0;i<3;i++) {
     //      auto w = make<Single>(b_model);
     //      scene->add(w);
     //      w->setPhysicsState(P_State::PASSIVE);
     //      walls << w;   w->opt_idx_cache = addToGrid(w);
     //      w->joint = [w](){
     //           for(auto i : w->opt_idx_cache) {grid->cells[i].erase(w->ID);}
     //           w->updateTransform(false);
     //           w->opt_idx_cache = addToGrid(w);
     //           return false;
     //      };
     // }

     


     list<std::function<void()>> from_phys_to_update;

     map<std::string,double> total_times;
     S_Tool phys_logger;
     #if GTIMERS
     phys_logger.log = [agents,phys,&crumb_managers,&total_times,amt,&stats](){
          // map<std::string,double> times;
          // int accum4 = 0;
          // int accum5 = 0;
          // for(auto a : agents) {
          //      for(int i=0;i<a->timers.length();i++) {
          //           times.getOrPut(a->timer_labels[i],0) += a->timers[i];
          //      }
          //      accum4 += a->opt_ints[4];
          //      accum5 += a->opt_ints[5];
          //      a->opt_ints[5] = 0;
          // }
          // print("------------\n AGENT JOINT TIMES");
          // for(auto e : times.entrySet()) {
          //      print(e.key,": ",ftime(e.value)," (total: ",ftime(total_times.getOrDefault(e.key,0.0)),")");
          // }
          // for(auto e : total_times.entrySet()) {
          //      if(!times.hasKey(e.key)) {
          //           print("(",e.key,": ",ftime(e.value),")");
          //      }

          // }
          // total_times.clear();
          // print("Total crumbs observed: ",accum4);
          // print("Evaluated spatial queries since last log: ",accum5);

          // std::function<int(g_ptr<CategoryNode>)> instances_in_cateogry = [&](g_ptr<CategoryNode> c){
          //      int total = c->store->crumbs.length();
          //      for(auto child : c->children) {
          //           total += instances_in_cateogry(child);
          //      }
          //      return total;
          // };

          // int total = 0;
          // int start_idx = randi(0,amt-1);
          // for(int i=start_idx;i<start_idx+10;i++) {
          //      if(i>=amt) break;
          //      g_ptr<crumb_manager> c = crumb_managers[i];
          //      total += instances_in_cateogry(c->meta_root);
          // }
          // print("Avg crumbs in memory: ",total/10);
     };
     #endif
     run_thread->name = "Physics";
     Log::Line time; time.start();
     run_thread->run([&stats,&time, phys,&phys_logger,&total_times,&agents,update_thread,&crumbs,&crumb_managers,&from_phys_to_update](ScriptContext& ctx){
          phys_logger.tick();
          if(use_grid&&phys->collisonMethod!=Physics::GRID) {
               phys->collisonMethod = Physics::GRID;
               phys->grid = grid;
          } else if(!use_grid&&phys->collisonMethod!=Physics::AABB) {
               phys->collisonMethod = Physics::AABB;
               phys->treeBuilt3d = false;
          }
          phys->updatePhysics();
          for(auto a : agents) {
               for(int i=0;i<a->timers.length();i++) {
                    total_times.getOrPut(a->timer_labels[i],0) += a->timers[i];
               }
          }
          stats.frame_count++;
               
          // Clear debug visuals every 30 frames (keep them visible but fresh)
          if(stats.frame_count % 30 == 0) {
              stats.clear_debug();
          }
          

          if(stats.frame_count % 50000 == 0) {
               float avg_dist = stats.total_distance / (agents.length() * 500);
               float avg_reward = stats.total_reward / (agents.length() * 500);
               
               auto sample_learner = (HotColdLearner*)agents[0]->opt_ptr.getPtr();
               
               print("\n=== LEARNING METRICS (frame ", stats.frame_count, ", time: ",ftime(time.end()),") ===");
               print("Avg distance to target: ", avg_dist, " units");
               print("Avg reward per step: ", avg_reward);
               print("Sample mouse stats:");
               print("  - Cumulative reward: ", sample_learner->cumulative_reward);
               print("  - Best distance: ", sample_learner->best_distance);
               print("  - Times reached goal: ", sample_learner->times_reached_goal);
               print("  - Steps taken: ", sample_learner->steps_taken);
               print("  - Replay buffer size: ", sample_learner->replay_buffer.length(), 
                     "/", MAX_BUFFER_SIZE);
               print("  - Learning rate: ", sample_learner->brain->get_lr());
               time.start();
               int close_count = 0;
               int goal_count = 0;
               for(auto a : agents) {
                   auto l = (HotColdLearner*)a->opt_ptr.getPtr();
                   float dist = a->getPosition().distance(l->hidden_target);
                   if(dist < 20.0f) close_count++;
                   goal_count += l->times_reached_goal;
               }
               
               print("Mice within 20 units: ", close_count, "/", agents.length());
               print("Total goals reached: ", goal_count);
               print("Current exploration rate: ", 0.05f + 0.25f * exp(-stats.frame_count / 2000.0f));
               
               stats.total_distance = 0;
               stats.total_reward = 0;
           }
     },0.0001f);
     #if GTIMERS
          run_thread->logSPS = true;
     #endif

     S_Tool update_logger;
     #if GTIMERS
     update_logger.log = [agents,&crumb_managers](){
          map<std::string,double> times;
          int accum4 = 0;
          int accum5 = 0;
          for(auto a : agents) {
               for(int i=0;i<a->timers2.length();i++) {
                    times.getOrPut(a->timer_labels2[i],0) += a->timers2[i];
               }
               accum4 += a->opt_ints[4];
               accum5 += a->opt_ints[5];
          }
          print("------------\n AGENT UPDATE TIMES");
          for(auto e : times.entrySet()) {
               print(e.key,": ",ftime(e.value));
          }
          // print("Observations processed: ",accum5);

          print("TOTAL CONNECTIONS: ",add_commas(total_connections));
     };
     #endif
     update_thread->name = "Update";
     update_thread->run([&update_logger,&agents,&from_phys_to_update](ScriptContext& ctx){
          update_logger.tick();
          for(auto a : agents) {
               if(a->threadUpdate&&a->isActive())
                    a->threadUpdate();
          }
          if(!from_phys_to_update.empty()) {
               for(auto p : from_phys_to_update) {
                      p();
               }
               from_phys_to_update.clear();
            }
     },0.008f);
     #if GTIMERS
          update_thread->logSPS = true;
     #endif


     S_Tool s_tool;
     #if GTIMERS
          s_tool.log_fps = true;
     #endif

     //For tree visualization
     g_ptr<crumb_manager> mem = crumb_managers[0];
     g_ptr<CategoryNode> current_view = mem->meta_root;
     int child_index = 0;  // Which child we're looking at
     int parent_index = 0; // Which parent we're looking at

     start::run(window,d,[&]{
          s_tool.tick();
          if(pressed(N)) {
               scene->camera.setTarget(agents[0]->getPosition()+vec3(0,20,20));
          }
          vec3 mousepos = scene->getMousePos();

          if(pressed(SPACE)) {
               if(run_thread->runningTurn) run_thread->pause();
               else run_thread->start();
          }
          if(pressed(P)) {
               if(held(LSHIFT)) {
                    run_thread->setSpeed(run_thread->getSpeed()/2); 
               } else {
                    if(run_thread->getSpeed()==0) 
                         run_thread->setSpeed(1.0f);
                    run_thread->setSpeed(run_thread->getSpeed()*2); 
               }
               print("Thread speed to: ",run_thread->getSpeed());
          }

          if(amt==1) {
               // Navigate DOWN to children
               if(pressed(E)) {
                    if(held(LSHIFT)) { // Cycle through siblings
                        if(!current_view->children.empty()) {
                            child_index = (child_index + 1) % current_view->children.length();
                            mem->visualize_structure(current_view);
                            print("Viewing child ", child_index, " of ", current_view->children.length());
                        }
                    } else {
                        if(!current_view->children.empty()) {
                            // Clamp to valid range before moving
                            child_index = child_index % current_view->children.length();
                            current_view = current_view->children[child_index];
                            mem->visualize_structure(current_view);
                            print("Moved to child ", child_index, ". Children: ", current_view->children.length(), 
                                  ", Parents: ", current_view->parents.length());
                        }
                    }
                }
               
               // Navigate UP to parents
               if(pressed(Q)) {
                    if(held(LSHIFT)) { // Cycle through parents
                         if(!current_view->parents.empty()) {
                             parent_index = (parent_index + 1) % current_view->parents.length();
                             mem->visualize_structure(current_view);
                             print("Viewing parent ", parent_index, " of ", current_view->parents.length());
                         }
                     } else {
                         if(!current_view->parents.empty()) {
                             g_ptr<CategoryNode> parent(current_view->parents[parent_index]);
                             current_view = parent;
                             // DON'T reset indices - keep them!
                             mem->visualize_structure(current_view);
                             print("Moved to parent ", parent_index, ". Children: ", current_view->children.length(), 
                                   ", Parents: ", current_view->parents.length());
                         }
                     }
               }
               
               // Reset to agent's current attention
               if(pressed(R)) {
                    current_view = mem->physics_attention.last();
                    child_index = 0;
                    parent_index = 0;
                    mem->visualize_structure(current_view);
                    print("Reset to current attention head");
               }

               //Visualize from root
               if(pressed(V)) {
                    mem->visualize_structure(mem->meta_root);
                    current_view = mem->meta_root;
                    print("Viewing full tree from root");
               }
               
               if(pressed(C)) {
                    mem->clear_debug();
               }

               if(pressed(G)) {
                    mem->find_duplicates();
                    mem->visualize_registry();
               }

               if(pressed(MOUSE_LEFT)) {
                    vec3 from = agents[0]->getPosition();
                    vec3 point = scene->getMousePos();
                    float dist = from.distance(point);
                    print("Dist: ",dist);
                    vec3 dir = from.direction(point);
                    auto cast = grid->raycast(from,dir,dist+1.0f,agents[0]->ID);
                    print("Hit at: ",cast.first," cell: ",cast.second," which has ",grid->getCell(cast.second).length()," objects");
                    for(auto d : grid->getCell(cast.second)) {
                         print("Blocked by a : ",scene->singles[d]->dtype);
                    }
                    crumb_managers[0]->debug << draw_line(from,from + dir * cast.first,"white",0.5f);
     
                    print("Can he see your mouse? ",grid->can_see(agents[0]->getPosition(),scene->getMousePos())?"Yes!":"No.");
                    print("Can he see your mouse if he's exclued? ",grid->can_see(agents[0]->getPosition(),point,{agents[0]->ID})?"Yes!":"No.");
     
               }
          }



          // if(pressed(E)) {
          //      if(on_wall++>=walls.length()-1) {
          //           on_wall = 0;
          //      }
          // }

          // static vec3 drag_start_pos;
          // static bool dragging = false;
          // if(held(MOUSE_LEFT)) {
          //     if(!walls.empty()) {
          //         g_ptr<Single> wall = walls[on_wall];
          //         if(held(LSHIFT)) {
          //             wall->setPosition(mousepos);
          //         } else {
          //             if(!dragging) {
          //                 drag_start_pos = wall->getPosition();
          //                 dragging = true;
          //             }
                      
          //             float dist = drag_start_pos.distance(mousepos);
          //             wall->faceTo(mousepos);
          //             wall->setScale({1, 1, dist});
                      
          //             // Position at start, then offset by half the distance
          //             vec3 offset = wall->facing() * (dist / 2.0f);
          //             wall->setPosition(drag_start_pos + offset);
          //         }
          //     }
          // } else {
          //     dragging = false;
          // }
          // int used_markers = 0;
          // for(int i=0;i<grid->cells.length();i++) {
          //      if(!grid->cells[i].empty()) {
          //           ray_markers[used_markers++]->setPosition(grid->indexToLoc(i));
          //      }
          // }
          // for(int i=0;i<ray_markers.length();i++) {
          //      if(i<=used_markers) {
          //           scene->reactivate(ray_markers[i]);
          //      } else if(ray_markers[i]->isActive()) {
          //           scene->deactivate(ray_markers[i]);
          //      }
          // }

          // list<vec3> test_dirs = {
          //      vec3(1,0,0), vec3(1,0,1).normalized(), vec3(0,0,1), 
          //      vec3(-1,0,1).normalized(), vec3(-1,0,0), vec3(-1,0,-1).normalized(),
          //      vec3(0,0,-1), vec3(1,0,-1).normalized()
          //  };
           
          //  vec3 test_pos = test_origin->getPosition();
          //  for(int i = 0; i < test_dirs.length(); i++) {
          //      float hit_dist = phys->raycast(test_pos, test_dirs[i], 10.0f);
          //      vec3 hit_point = test_pos + test_dirs[i] * hit_dist;
          //      ray_markers[i]->setPosition(hit_point);
          //  }

     });
     return 0;
}
