#include<test_q_list.hpp>
#include<thread>
#include<chrono>
#include<random>
#include<queue>

//using namespace Golden;
template<typename... Args>
void print(Args&&... args) {
  (std::cout << ... << args) << std::endl;
}

void test_authority_system()
{
    print("\n=== Authority System Test ===");
    
    std::atomic<bool> running{true};
    std::atomic<int> operations_completed{0};
    std::atomic<int> consistency_errors{0};
    
    q_list<int> game_objects;
    q_list<std::string> object_types;
    q_list<float> health_values;
    
    // Pre-populate with some data
    for(int i = 0; i < 20; ++i) {
        game_objects << i * 10;
        object_types << ("object_" + std::to_string(i));
        health_values << 100.0f;
    }
    
    // Thread 1: Object Manager (adds/removes objects)
    std::thread object_manager([&]{
        int object_id = 1000;
        while(running) {
            // Add objects
            if(game_objects.length() < 50) {
                game_objects << object_id;
                object_types << ("spawned_" + std::to_string(object_id));
                health_values << 100.0f;
                print("Manager: Added object ", object_id);
                object_id++;
                operations_completed++;
            }
            
            // Remove objects occasionally
            if(game_objects.length() > 10 && object_id % 5 == 0) {
                size_t remove_idx = game_objects.length() / 2;
                print("Manager: Removing object at index ", remove_idx);
                game_objects.remove(remove_idx);
                object_types.remove(remove_idx);
                health_values.remove(remove_idx);
                operations_completed++;
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    });

    // Thread 2: Game Logic (modifies existing objects)
    std::thread game_logic([&]{
        while(running) {
            if(game_objects.length() > 0) {
                size_t idx = rand() % game_objects.length();
                
                // Check consistency across arrays
                int obj_val = game_objects[idx];
                std::string obj_type = object_types[idx];
                float obj_health = health_values[idx];
                
                // Verify they seem to belong together (basic sanity check)
                if(obj_health < 0 || obj_health > 200) {
                    consistency_errors++;
                    print("Logic: Consistency error - invalid health ", obj_health, " at index ", idx);
                }
                
                // Modify health
                health_values[idx] = obj_health - 1.0f;
                if(health_values[idx] <= 0) {
                    health_values[idx] = 100.0f; // "respawn"
                }
                
                operations_completed++;
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(16));
        }
    });
    
    // Thread 3: Observer (reads data, simulates rendering/physics)
    std::thread observer([&]{
        while(running) {
            if(game_objects.length() > 0) {
                // Read all data (simulating rendering pass)
                for(size_t i = 0; i < game_objects.length(); ++i) {
                    int obj = game_objects[i];
                    std::string type = object_types[i];
                    float health = health_values[i];
                    
                    // Basic sanity checks
                    if(health < 0 || health > 200) {
                        consistency_errors++;
                    }
                    
                    operations_completed++;
                }
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(32)); // ~30 FPS observer
        }
    });
    
    // Let it run for a few seconds
    std::this_thread::sleep_for(std::chrono::seconds(3));
    running.store(false);
    
    object_manager.join();
    game_logic.join();
    observer.join();
    
    print("Authority test completed:");
    print("  Operations: ", operations_completed.load());
    print("  Consistency errors: ", consistency_errors.load());
    print("  Final object count: ", game_objects.length());
    print("  Success rate: ", (1.0f - (float)consistency_errors.load() / operations_completed.load()) * 100, "%");
}

void test_rapid_coordination()
{
    print("\n=== Rapid Coordination Test ===");
    
    q_list<int> rapid_list;
    std::atomic<int> successful_operations{0};
    std::atomic<bool> running{true};
    
    // Pre-populate
    for(int i = 0; i < 100; ++i) {
        rapid_list << i;
    }
    
    auto start_time = std::chrono::high_resolution_clock::now();
    
    // Rapid adder
    std::thread adder([&]{
        int value = 10000;
        while(running) {
            rapid_list << value++;
            successful_operations++;
        }
    });
    
    // Rapid remover  
    std::thread remover([&]{
        while(running) {
            if(rapid_list.length() > 50) {
                rapid_list.remove(rapid_list.length() / 2);
                successful_operations++;
            }
            std::this_thread::yield();
        }
    });
    
    // Rapid reader
    std::thread reader([&]{
        while(running) {
            for(size_t i = 0; i < std::min((size_t)10, rapid_list.length()); ++i) {
                volatile int val = rapid_list[i]; // Force read
                successful_operations++;
            }
        }
    });
    
    // Run for 1 second
    std::this_thread::sleep_for(std::chrono::seconds(1));
    running.store(false);
    
    adder.join();
    remover.join(); 
    reader.join();
    
    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);
    
    print("Rapid coordination completed:");
    print("  Total operations: ", successful_operations.load());
    print("  Operations/second: ", successful_operations.load() * 1000000.0 / duration.count());
    print("  No crashes = coordination working!");
}

void test_edge_case_coordination()
{
    print("\n=== Edge Case Coordination Test ===");
    
    q_list<int> edge_list;
    
    // Test: Rapid add/remove on small list
    edge_list << 1;
    edge_list << 2; 
    edge_list << 3;
    
    std::thread rapid_modifier([&]{
        for(int i = 0; i < 100; ++i) {
            edge_list << i;
            if(edge_list.length() > 1) {
                edge_list.remove(0);
            }
        }
    });
    
    std::thread rapid_reader([&]{
        for(int i = 0; i < 1000; ++i) {
            if(edge_list.length() > 0) {
                volatile int val = edge_list[0];
            }
            std::this_thread::yield();
        }
    });
    
    rapid_modifier.join();
    rapid_reader.join();
    
    print("Edge case test completed - no crashes!");
    
    // Test: Remove from single element
    q_list<int> single;
    single << 42;
    single.remove(0);
    print("Single element removal: length = ", single.length());
    
    // Test: Multiple rapid removals
    q_list<int> multi;
    for(int i = 0; i < 10; ++i) multi << i;
    
    while(multi.length() > 0) {
        multi.remove(0);
    }
    print("Multi removal: final length = ", multi.length());
}

void test_redirection_accuracy()
{
    print("\n=== Redirection Accuracy Test ===");
    
    q_list<std::string> redirect_test;
    
    // Setup known data
    redirect_test << "A"; 
    redirect_test << "B";
    redirect_test << "C";
    redirect_test << "D";
    redirect_test << "E";
    
    std::atomic<bool> removal_started{false};
    std::atomic<bool> removal_done{false};
    std::string observed_values[5];
    
    // Thread 1: Remove element C (index 2)  
    std::thread remover([&]{
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        removal_started.store(true);
        redirect_test.remove(2); // Remove "C", "E" should move to position 2
        removal_done.store(true);
    });
    
    // Thread 2: Observer watching the redirection
    std::thread observer([&]{
        while(!removal_done.load()) {
            if(removal_started.load()) {
                // During removal, access should be redirected correctly
                if(redirect_test.length() >= 4) {
                    observed_values[0] = redirect_test[0]; // Should be "A"
                    observed_values[1] = redirect_test[1]; // Should be "B" 
                    observed_values[2] = redirect_test[2]; // Should be redirected
                    observed_values[3] = redirect_test[3]; // Should be "D"
                    // Don't access [4] as it's being removed
                }
            }
            std::this_thread::yield();
        }
    });
    
    remover.join();
    observer.join();
    
    print("Redirection test - observed during removal:");
    print("  [0]: ", observed_values[0]);
    print("  [1]: ", observed_values[1]); 
    print("  [2]: ", observed_values[2]);
    print("  [3]: ", observed_values[3]);
    
    print("Final state:");
    for(size_t i = 0; i < redirect_test.length(); ++i) {
        print("  [", i, "]: ", redirect_test[i]);
    }
}

void test_performance_comparison()
{
    print("\n=== Performance vs Mutex Comparison ===");
    
    const int operations = 50000;
    
    // Test q_list
    auto start = std::chrono::high_resolution_clock::now();
    {
        q_list<int> qlist;
        std::atomic<bool> running{true};
        
        std::thread adder([&]{
            for(int i = 0; i < operations/2; ++i) {
                qlist << i;
            }
        });
        
        std::thread reader([&]{
            int reads = 0;
            while(reads < operations/2) {
                if(qlist.length() > 0) {
                    volatile int val = qlist[0];
                    reads++;
                }
                std::this_thread::yield();
            }
        });
        
        adder.join();
        reader.join();
    }
    auto q_time = std::chrono::high_resolution_clock::now() - start;
    
    // Test mutex approach
    start = std::chrono::high_resolution_clock::now();
    {
        std::vector<int> vec;
        std::mutex vec_mutex;
        
        std::thread adder([&]{
            for(int i = 0; i < operations/2; ++i) {
                std::lock_guard<std::mutex> lock(vec_mutex);
                vec.push_back(i);
            }
        });
        
        std::thread reader([&]{
            int reads = 0;
            while(reads < operations/2) {
                std::lock_guard<std::mutex> lock(vec_mutex);
                if(!vec.empty()) {
                    volatile int val = vec[0];
                    reads++;
                }
                std::this_thread::yield();
            }
        });
        
        adder.join();
        reader.join();
    }
    auto mutex_time = std::chrono::high_resolution_clock::now() - start;
    
    print("Performance comparison (", operations, " operations):");
    print("  q_list: ", std::chrono::duration_cast<std::chrono::microseconds>(q_time).count(), "μs");
    print("  mutex:  ", std::chrono::duration_cast<std::chrono::microseconds>(mutex_time).count(), "μs");
    print("  Speedup: ", (double)mutex_time.count() / q_time.count(), "x");
}

void test_removal_race_condition()
{
    print("\n=== Removal Race Condition Test ===");
    
    // This test tries to force the exact timing that causes the crash
    int crashes = 0;
    int successful_runs = 0;
    
    for(int run = 0; run < 100; ++run) {
        try {
            q_list<std::string> race_list;
            
            // Setup known data
            race_list << "A" << "B" << "C" << "D" << "E" << "F" << "G" << "H";
            
            std::atomic<bool> start_removal{false};
            std::atomic<bool> removal_in_progress{false};
            std::atomic<bool> force_collision{false};
            std::string crash_value = "";
            
            // Thread 1: Remover - removes from middle
            std::thread remover([&]{
                std::this_thread::sleep_for(std::chrono::microseconds(100));
                start_removal.store(true);
                
                // Give reader thread time to detect and prepare
                std::this_thread::sleep_for(std::chrono::microseconds(10));
                
                removal_in_progress.store(true);
                race_list.remove(3); // Remove "D", "H" should move to position 3
                removal_in_progress.store(false);
            });
            
            // Thread 2: Aggressive reader - tries to access during vulnerable window
            std::thread reader([&]{
                while(!start_removal.load()) {
                    std::this_thread::yield();
                }
                
                // Wait for removal to actually start
                while(!race_list.isRemoving()) {
                    std::this_thread::yield();
                }
                
                // NOW hammer the exact indices that are being redirected
                for(int i = 0; i < 1000; ++i) {
                    try {
                        // Access the index being removed (should redirect)
                        crash_value = race_list[3]; 
                        
                        // Access the last index (should redirect with warning)  
                        crash_value = race_list[7];
                        
                        // Access out of bounds during removal
                        if(race_list.length() > 0) {
                            crash_value = race_list[race_list.length() - 1];
                        }
                        
                    } catch(const std::exception& e) {
                        force_collision.store(true);
                        throw; // Re-throw to be caught by outer try
                    }
                    
                    // Tiny yield to increase chance of hitting the exact timing
                    if(i % 10 == 0) std::this_thread::yield();
                }
            });
            
            remover.join();
            reader.join();
            
            successful_runs++;
            
        } catch(const std::exception& e) {
            crashes++;
            print("Run ", run, " crashed: ", e.what());
        }
    }
    
    print("Removal race condition results:");
    print("  Successful runs: ", successful_runs);
    print("  Crashes: ", crashes);
    print("  Crash rate: ", (float)crashes / (crashes + successful_runs) * 100, "%");
}
void test_controlled_aggressive_timing()
{
    print("\n=== Controlled Aggressive Timing Test ===");
    
    std::atomic<int> successful_operations{0};
    std::atomic<int> caught_exceptions{0};
    std::atomic<int> warnings_issued{0};
    std::atomic<bool> fatal_error{false};
    
    for(int round = 0; round < 10; ++round) {
        if(fatal_error.load()) break;
        
        try {
            q_list<std::string> aggressive_list;
            
            // Pre-populate with identifiable data
            for(int i = 0; i < 15; ++i) {
                aggressive_list << ("item_" + std::to_string(i));
            }
            
            std::atomic<bool> round_running{true};
            std::atomic<int> removals_completed{0};
            std::atomic<int> accesses_attempted{0};
            
            // Remover thread - removes every 5ms (200 Hz - more aggressive than normal)
            std::thread remover([&]{
                int removal_count = 0;
                while(round_running.load() && removal_count < 8) {
                    if(aggressive_list.length() > 5) {
                        size_t remove_idx = aggressive_list.length() / 2;
                        print("Round ", round, " - Removing index ", remove_idx, " (length was ", aggressive_list.length(), ")");
                        
                        aggressive_list.remove(remove_idx);
                        removals_completed++;
                        removal_count++;
                        successful_operations++;
                    }
                    std::this_thread::sleep_for(std::chrono::milliseconds(5)); // 200 Hz
                }
            });
            
            // Aggressive reader - reads every 1ms but with safety checks
            std::thread aggressive_reader([&]{
                int read_count = 0;
                while(round_running.load() && read_count < 100) {
                    try {
                        size_t current_length = aggressive_list.length();
                        
                        if(current_length > 0) {
                            // Test different access patterns
                            switch(read_count % 4) {
                                case 0: {
                                    // Access first element
                                    std::string val = aggressive_list.get(0, "aggressive_reader_first");
                                    accesses_attempted++;
                                    break;
                                }
                                case 1: {
                                    // Access last element (most likely to cause issues)
                                    if(current_length > 0) {
                                        std::string val = aggressive_list.get(current_length - 1, "aggressive_reader_last");
                                        accesses_attempted++;
                                    }
                                    break;
                                }
                                case 2: {
                                    // Access middle element
                                    if(current_length > 2) {
                                        std::string val = aggressive_list.get(current_length / 2, "aggressive_reader_middle");
                                        accesses_attempted++;
                                    }
                                    break;
                                }
                                case 3: {
                                    // Access random element
                                    if(current_length > 0) {
                                        size_t random_idx = read_count % current_length;
                                        std::string val = aggressive_list.get(random_idx, "aggressive_reader_random");
                                        accesses_attempted++;
                                    }
                                    break;
                                }
                            }
                        }
                        
                        successful_operations++;
                        read_count++;
                        
                    } catch(const std::exception& e) {
                        caught_exceptions++;
                        print("Round ", round, " - Reader exception: ", e.what());
                        
                        // Don't break on exceptions, just count them
                        if(caught_exceptions.load() > 20) {
                            print("Too many exceptions, stopping round ", round);
                            break;
                        }
                    }
                    
                    std::this_thread::sleep_for(std::chrono::milliseconds(1)); // 1000 Hz reading
                }
            });
            
            // Let this round run for a short time
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            round_running.store(false);
            
            remover.join();
            aggressive_reader.join();
            
            print("Round ", round, " completed:");
            print("  Removals: ", removals_completed.load());
            print("  Access attempts: ", accesses_attempted.load());
            print("  Final length: ", aggressive_list.length());
            
        } catch(const std::exception& e) {
            fatal_error.store(true);
            print("FATAL ERROR in round ", round, ": ", e.what());
            break;
        } catch(...) {
            fatal_error.store(true);
            print("UNKNOWN FATAL ERROR in round ", round);
            break;
        }
        
        // Small break between rounds
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
    
    print("\nControlled aggressive test summary:");
    print("  Total successful operations: ", successful_operations.load());
    print("  Total caught exceptions: ", caught_exceptions.load());
    print("  Fatal errors: ", fatal_error.load() ? "YES" : "NO");
    print("  Exception rate: ", (float)caught_exceptions.load() / successful_operations.load() * 100, "%");
}

void test_specific_race_window()
{
    print("\n=== Specific Race Window Test ===");
    
    std::atomic<int> race_hits{0};
    std::atomic<int> successful_redirections{0};
    
    for(int attempt = 0; attempt < 20; ++attempt) {
        try {
            q_list<int> race_list;
            
            for(int i = 0; i < 5; ++i) {
                race_list << i * 100;
            }
            
            std::atomic<bool> start_reading{false};
            std::atomic<bool> test_completed{false};
            
            std::thread remover([&]{
                std::this_thread::sleep_for(std::chrono::microseconds(100));
                start_reading.store(true);  // Signal reader to start
                
                // Give reader time to start its tight loop
                std::this_thread::sleep_for(std::chrono::microseconds(50));
                
                race_list.remove(2);
                test_completed.store(true);  // Signal completion
            });
            
            std::thread reader([&]{
                while(!start_reading.load()) {
                    std::this_thread::yield();
                }
                
                // Tight loop trying to hit the vulnerable window
                int attempts = 0;
                while(!test_completed.load() && attempts < 10000) {
                    try {
                        int val1 = race_list.get(2, "race_reader_removed_pos");
                        int val2 = race_list.get(4, "race_reader_moved_pos");
                        successful_redirections += 2;
                    } catch(const std::exception& e) {
                        race_hits++;
                        print("Attempt ", attempt, " - Race condition hit: ", e.what());
                        break;  // Exit on first error
                    }
                    attempts++;
                }
                
                if(attempts >= 10000) {
                    print("Attempt ", attempt, " - Reader gave up after 10000 tries");
                }
            });
            
            remover.join();
            reader.join();
            
        } catch(...) {
            race_hits++;
            print("Attempt ", attempt, " - Unhandled race condition");
        }
    }
    
    print("Race window test results:");
    print("  Successful redirections: ", successful_redirections.load());
    print("  Race hits: ", race_hits.load());
}

struct TestScenario {
    std::string name;
    int removal_frequency_hz;    // How often removals happen
    int access_frequency_hz;     // How often accesses happen  
    int duration_seconds;        // How long to test
    int expected_hits_per_hour;  // Theoretical prediction
};

void test_race_probability_scenario(const TestScenario& scenario)
{
    print("\n=== Testing Scenario: ", scenario.name, " ===");
    print("Removal frequency: ", scenario.removal_frequency_hz, " Hz");
    print("Access frequency: ", scenario.access_frequency_hz, " Hz");
    print("Predicted hits/hour: ", scenario.expected_hits_per_hour);
    
    std::atomic<int> race_hits{0};
    std::atomic<int> total_accesses{0};
    std::atomic<int> total_removals{0};
    std::atomic<bool> test_running{true};
    
    q_list<int> scenario_list;
    
    // Pre-populate
    for(int i = 0; i < 50; ++i) {
        scenario_list << i;
    }
    
    auto start_time = std::chrono::steady_clock::now();
    
    // Removal thread
    std::thread remover([&]{
        auto next_removal = std::chrono::steady_clock::now();
        auto removal_interval = std::chrono::nanoseconds(1000000000 / scenario.removal_frequency_hz);
        
        while(test_running.load()) {
            auto now = std::chrono::steady_clock::now();
            if(now >= next_removal && scenario_list.length() > 10) {
                size_t remove_idx = scenario_list.length() / 2;
                scenario_list.remove(remove_idx);
                total_removals++;
                next_removal = now + removal_interval;
            }
            std::this_thread::sleep_for(std::chrono::microseconds(10));
        }
    });
    
    // Access thread
    std::thread accessor([&]{
        auto next_access = std::chrono::steady_clock::now();
        auto access_interval = std::chrono::nanoseconds(1000000000 / scenario.access_frequency_hz);
        
        while(test_running.load()) {
            auto now = std::chrono::steady_clock::now();
            if(now >= next_access) {
                try {
                    if(scenario_list.length() > 0) {
                        size_t access_idx = total_accesses.load() % scenario_list.length();
                        volatile int val = scenario_list.get(access_idx, "scenario_accessor");
                        total_accesses++;
                    }
                } catch(const std::exception& e) {
                    race_hits++;
                    total_accesses++;  // Count it as an access attempt
                }
                next_access = now + access_interval;
            }
            
            // Sleep for a fraction of the access interval
            auto sleep_time = access_interval / 10;
            if(sleep_time > std::chrono::microseconds(1)) {
                std::this_thread::sleep_for(sleep_time);
            } else {
                std::this_thread::yield();
            }
        }
    });
    
    // Run for specified duration
    std::this_thread::sleep_for(std::chrono::seconds(scenario.duration_seconds));
    test_running.store(false);
    
    remover.join();
    accessor.join();
    
    auto end_time = std::chrono::steady_clock::now();
    auto actual_duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
    
    // Calculate actual rates
    float actual_hours = actual_duration.count() / 1000.0f / 3600.0f;
    float actual_hit_rate = (float)race_hits.load() / total_accesses.load() * 100;
    float actual_hits_per_hour = race_hits.load() / actual_hours;
    
    print("Results:");
    print("  Duration: ", actual_duration.count(), "ms");
    print("  Total accesses: ", total_accesses.load());
    print("  Total removals: ", total_removals.load());
    print("  Race hits: ", race_hits.load());
    print("  Hit rate: ", actual_hit_rate, "%");
    print("  Hits per hour (actual): ", actual_hits_per_hour);
    print("  Hits per hour (predicted): ", scenario.expected_hits_per_hour);
    print("  Prediction accuracy: ", (float)scenario.expected_hits_per_hour / actual_hits_per_hour * 100, "%");
}

void test_all_scenarios()
{
    print("🎲 Race Condition Probability Analysis\n");
    
    std::vector<TestScenario> scenarios = {
        {"Light Game Usage", 2, 1000, 5, 1},           // 2 removals/sec, 1K accesses/sec
        {"Typical Game Usage", 10, 10000, 3, 30},      // 10 removals/sec, 10K accesses/sec  
        {"Heavy Game Usage", 60, 100000, 2, 1800},     // 60 removals/sec, 100K accesses/sec
        {"Stress Test", 200, 1000000, 1, 60000},       // 200 removals/sec, 1M accesses/sec
        {"Aggressive Test", 500, 10000000, 1, 1500000} // 500 removals/sec, 10M accesses/sec
    };
    
    for(const auto& scenario : scenarios) {
        test_race_probability_scenario(scenario);
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Brief pause between tests
    }
}

struct GoldenSimConfig {
    int num_arrays = 5;
    int initial_objects = 50;
    int max_objects = 100;
    int test_duration_ms = 1000;
    int add_frequency_ms = 20;      // Add every 20ms
    int remove_frequency_ms = 50;   // Remove every 50ms  
    int read_frequency_ms = 2;      // Read every 2ms (500 Hz)
    int arrays_per_read = 3;        // How many arrays to read per cycle
    bool log_operations = false;
    std::string scenario_name = "default";
};

class MockGoldenScene {
private:
    // Simple ID management (like your Scene)
    size_t nextId = 0;
    std::queue<size_t> freeIds;
    
    // Fixed arrays - can't use vector with q_list since no copy constructor
    q_list<int> array_0;
    q_list<int> array_1; 
    q_list<int> array_2;
    q_list<int> array_3;
    q_list<int> array_4;
    q_list<int> array_5;
    q_list<int> array_6;
    q_list<int> array_7;
    int actual_num_arrays;
    
    size_t getUid() {
        if (!freeIds.empty()) {
            size_t id = freeIds.front();
            freeIds.pop();
            return id;
        } else {
            return nextId++;
        }
    }
    
    q_list<int>& getArray(int index) {
        switch(index) {
            case 0: return array_0;
            case 1: return array_1;
            case 2: return array_2;
            case 3: return array_3;
            case 4: return array_4;
            case 5: return array_5;
            case 6: return array_6;
            case 7: return array_7;
            default: return array_0; // Fallback
        }
    }
    
public:
    
    // UUID to object mapping (simplified - just stores the ID)
    map<size_t, size_t> objects;  // UUID -> current ID
    std::atomic<int> successful_reads{0};
    std::atomic<int> failed_reads{0};
    std::atomic<int> id_drift_detected{0};
    std::atomic<int> uuid_misses{0};
    std::atomic<int> objects_added{0};
    std::atomic<int> objects_removed{0};
    std::atomic<int> stale_reads{0};        // Read data that belonged to a different object
    std::atomic<int> index_out_of_bounds{0}; // Tried to read past array end
    
    MockGoldenScene(int num_arrays) : actual_num_arrays(std::min(num_arrays, 8)) {
        // Initialize arrays with different data patterns
        for(int array_idx = 0; array_idx < actual_num_arrays; ++array_idx) {
            for(int i = 0; i < 50; ++i) {
                getArray(array_idx) << (array_idx * 1000 + i);
            }
        }
        
        // Create initial UUID mappings
        for(size_t i = 0; i < 50; ++i) {
            size_t uuid = getUid();
            objects.put(uuid, i);  // UUID maps to ID i
        }
    }
    
    void addObject() {
        size_t uuid = getUid();
        size_t new_id = getArray(0).length();  // New objects go at the end
        
        // Add to all arrays
        for(int array_idx = 0; array_idx < actual_num_arrays; ++array_idx) {
            getArray(array_idx) << (array_idx * 1000 + (int)new_id);
        }
        
        // Map UUID to ID
        objects.put(uuid, new_id);
        objects_added++;
    }
    
    void removeObject() {
        auto uuids = objects.keySet();
        if(uuids.length() == 0) return;
        
        // Pick a random UUID to remove
        size_t uuid_to_remove = uuids[rand() % uuids.length()];
        
        if(!objects.hasKey(uuid_to_remove)) return;
        
        size_t id_to_remove = objects.get(uuid_to_remove);
        
        // Remove from all arrays (this causes ID drift!)
        for(int array_idx = 0; array_idx < actual_num_arrays; ++array_idx) {
            if(id_to_remove < getArray(array_idx).length()) {
                getArray(array_idx).remove(id_to_remove);
            }
        }
        
        // Update UUID mappings for swapped objects
        // The object that was at the end moved to id_to_remove position
        size_t new_length = getArray(0).length();
        
        // Find the UUID that was pointing to the last position (now moved to removed position)
        for(auto& uuid_pair : objects.entrySet()) {
            size_t uuid = uuid_pair.key;
            size_t current_id = uuid_pair.value;
            
            if(current_id == new_length) {  // This was the last object (before removal)
                objects.set(uuid, id_to_remove);  // It moved to the removed position
                break;
            }
        }
        
        // Remove the deleted object's UUID
        objects.remove(uuid_to_remove);
        freeIds.push(uuid_to_remove);
        objects_removed++;
    }
    
    void readObjects(int num_arrays_to_read, const std::string& reader_name) {
        auto uuids = objects.keySet();
        if(uuids.length() == 0) return;
        
        // Limit arrays to read to what we actually have
        int arrays_to_read = std::min(num_arrays_to_read, actual_num_arrays);
        
        // Pick random objects to read
        int reads_to_do = std::min(5, (int)uuids.length());
        for(int read = 0; read < reads_to_do; ++read) {
            size_t uuid = uuids[rand() % uuids.length()];
            
            if(!objects.hasKey(uuid)) {
                uuid_misses++;
                continue;
            }
            
            size_t object_id = objects.get(uuid);
            
            // Read from multiple arrays
            bool read_success = true;
            list<int> values_read;  // Use your custom list instead of vector
            
            for(int array_idx = 0; array_idx < arrays_to_read; ++array_idx) {
                try {
                    std::string from = reader_name + "_array" + std::to_string(array_idx);
                    int value = getArray(array_idx).get(object_id, from);
                    values_read << value;
                    
                } catch(const std::exception& e) {
                    failed_reads++;
                    read_success = false;
                    break;
                }
            }
            
            if(read_success) {
                // Check for ID drift - all arrays should have consistent relative values
                if(values_read.length() > 1) {
                    int expected_base = values_read[0] % 1000;
                    for(size_t i = 1; i < values_read.length(); ++i) {
                        int actual_base = values_read[i] % 1000;
                        if(actual_base != expected_base) {
                            id_drift_detected++;
                            break;
                        }
                    }
                }
                successful_reads++;
            }
        }
    }
    
    void physicsIteration(const std::string& reader_name) {
        // Physics doesn't use UUIDs - it just iterates through array indices!
        size_t array_length = getArray(0).length();
        
        // Iterate through all objects by index (like real physics)
        for(size_t i = 0; i < array_length; ++i) {
            try {
                if(i<=getArray(0).length()) continue;
                // Read from multiple arrays at the same index (like transform + velocity + physics state)
                std::string from = reader_name + "_index" + std::to_string(i);
                
                int transform_data = getArray(0).get(i, from + "_transform");
                int velocity_data = getArray(1).get(i, from + "_velocity");
                int physics_data = getArray(2).get(i, from + "_physics");
                
                // Check if data is consistent (should have same base ID)
                int transform_id = transform_data % 1000;
                int velocity_id = velocity_data % 1000;
                int physics_id = physics_data % 1000;
                
                if(transform_id != velocity_id || velocity_id != physics_id) {
                    // ID drift! Physics is operating on mismatched data
                    id_drift_detected++;
                   // if(config.log_operations) {
                        print("ID DRIFT at index ", i, ": transform=", transform_id, 
                              " velocity=", velocity_id, " physics=", physics_id);
                  //  }
                }
                
                successful_reads++;
                
            } catch(const std::exception& e) {
                // Array access failed - probably index out of bounds due to removal
                failed_reads++;
                index_out_of_bounds++;
                //if(config.log_operations) {
                    print("Physics failed to read index ", i, ": ", e.what());
                //}
            }
        }
    }
    
    // This simulates safe UUID-based access (like rendering or game logic)
    void safeUuidIteration(int num_arrays_to_read, const std::string& reader_name) {
        auto uuids = objects.keySet();
        if(uuids.length() == 0) return;
        
        // Pick random objects to read by UUID (safe approach)
        int reads_to_do = std::min(10, (int)uuids.length());
        for(int read = 0; read < reads_to_do; ++read) {
            size_t uuid = uuids[rand() % uuids.length()];
            
            if(!objects.hasKey(uuid)) {
                uuid_misses++;
                continue;
            }
            
            size_t object_id = objects.get(uuid);
            
            // Read from arrays using the UUID-mapped ID
            bool read_success = true;
            for(int array_idx = 0; array_idx < std::min(num_arrays_to_read, actual_num_arrays); ++array_idx) {
                try {
                    std::string from = reader_name + "_uuid_array" + std::to_string(array_idx);
                    int value = getArray(array_idx).get(object_id, from);
                    
                } catch(const std::exception& e) {
                    failed_reads++;
                    read_success = false;
                    break;
                }
            }
            
            if(read_success) {
                successful_reads++;
            }
        }
    }
    
    void printStats() {
        auto uuids = objects.keySet();
        print("  Objects in scene: ", uuids.length());
        print("  Array lengths: ", getArray(0).length());
        print("  Successful reads: ", successful_reads.load());
        print("  Failed reads: ", failed_reads.load());
        print("  ID drift detected: ", id_drift_detected.load());
        print("  Index out of bounds: ", index_out_of_bounds.load());
        print("  Stale reads: ", stale_reads.load());
        print("  UUID misses: ", uuid_misses.load());
        print("  Objects added: ", objects_added.load());
        print("  Objects removed: ", objects_removed.load());
    }
};

void test_golden_access_pattern(const GoldenSimConfig& config) {
    print("\n=== Golden Access Pattern: ", config.scenario_name, " ===");
    
    MockGoldenScene scene(config.num_arrays);
    std::atomic<bool> running{true};
    
    // Object manager thread (adds/removes objects)
    std::thread manager([&]{
        auto last_add = std::chrono::steady_clock::now();
        auto last_remove = std::chrono::steady_clock::now();
        
        while(running.load()) {
            auto now = std::chrono::steady_clock::now();
            
            // Add objects
            if(std::chrono::duration_cast<std::chrono::milliseconds>(now - last_add).count() >= config.add_frequency_ms) {
                auto uuids = scene.objects.keySet();
                if(uuids.length() < config.max_objects) {
                    scene.addObject();
                    if(config.log_operations) print("Manager: Added object");
                }
                last_add = now;
            }
            
            // Remove objects  
            if(std::chrono::duration_cast<std::chrono::milliseconds>(now - last_remove).count() >= config.remove_frequency_ms) {
                auto uuids = scene.objects.keySet();
                if(uuids.length() > 10) {
                    scene.removeObject();
                    if(config.log_operations) print("Manager: Removed object");
                }
                last_remove = now;
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
    });
    
    // PHYSICS SIMULATION - Does dangerous flat iteration!
    std::thread physics([&]{
        while(running.load()) {
            scene.physicsIteration("physics_flat");
            std::this_thread::sleep_for(std::chrono::milliseconds(config.read_frequency_ms));
        }
    });
    
    // GAME LOGIC - Uses safe UUID lookups
    std::thread logic([&]{
        while(running.load()) {
            scene.safeUuidIteration(2, "logic_safe");
            std::this_thread::sleep_for(std::chrono::milliseconds(config.read_frequency_ms * 2));
        }
    });
    
    // RENDERING - Uses safe UUID lookups
    std::thread renderer([&]{
        while(running.load()) {
            scene.safeUuidIteration(1, "render_safe");
            std::this_thread::sleep_for(std::chrono::milliseconds(config.read_frequency_ms * 3));
        }
    });
    
    std::this_thread::sleep_for(std::chrono::milliseconds(config.test_duration_ms));
    running.store(false);
    
    manager.join();
    physics.join();
    logic.join();
    renderer.join();
    
    print("Results for ", config.scenario_name, ":");
    scene.printStats();
    
    float success_rate = (float)scene.successful_reads.load() / (scene.successful_reads.load() + scene.failed_reads.load()) * 100;
    print("  Success rate: ", success_rate, "%");
    print("  ID drift rate: ", (float)scene.id_drift_detected.load() / scene.successful_reads.load() * 100, "%");
}

int main() {
    print("🎮 Golden Engine Access Pattern Simulation\n");
    
    // Scenario 1: Normal game conditions
    GoldenSimConfig normal;
    normal.scenario_name = "Normal Game";
    normal.add_frequency_ms = 100;
    normal.remove_frequency_ms = 200;
    normal.read_frequency_ms = 16;  // ~60 FPS
    test_golden_access_pattern(normal);
    
    // Scenario 2: Aggressive conditions (lots of spawning/despawning)
    GoldenSimConfig aggressive;
    aggressive.scenario_name = "Aggressive Spawning";
    aggressive.add_frequency_ms = 4;
    aggressive.remove_frequency_ms = 6;
    aggressive.read_frequency_ms = 1;
    aggressive.arrays_per_read = 4;
    test_golden_access_pattern(aggressive);
    
    // Scenario 3: High object count, stable
    GoldenSimConfig stable;
    stable.scenario_name = "High Count Stable";
    stable.max_objects = 200;  // Reduced since we can't resize easily
    stable.add_frequency_ms = 1000;  // Rare additions
    stable.remove_frequency_ms = 2000; // Rare removals
    stable.read_frequency_ms = 5;
    test_golden_access_pattern(stable);
    
    print("\n📊 Simulation complete!");
    return 0;
}