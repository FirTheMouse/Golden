#include<util/util.hpp>
#include<core/object.hpp>
#include<core/scriptable.hpp>
#include<util/d_list.hpp>

using namespace Golden;
using str = std::string;


list<str> newList(const str& s,char delimiter = ',')
{
    list<str> toReturn;
    int last = 0;
    for(int i=0;i<s.length();i++)
    {
        if(s.at(i)==delimiter) {
            toReturn << s.substr(last,i-last);
            last = i+1;
        }
    }
    if(last<s.length())
    {
        toReturn << s.substr(last,s.length()-last);
    }
    return toReturn;
}

struct S_Result
{
//S_Result(str _cmd,list<str> _lst) : cmd(_cmd), lst(_lst) {}
S_Result() {}
str cmd = "NONE";
list<str> lst;
str cbk = "NONE";
};

S_Result subParse(const str& s)
{
    S_Result toReturn;
    auto nl = newList(s,'|');
    if(nl.length()<=1) {toReturn.lst = nl; return toReturn;}
    str x = nl[1];
    toReturn.cmd = x;
    toReturn.cbk = nl[0];
    nl.removeAt(0); nl.removeAt(0);
    toReturn.lst = nl;
    return toReturn;
}

bool contains(const str& s,const str& l)
{
    int p = 0;
    for(int i=0;i<s.length();i++)
    {
        if(p==l.length()) return true;
        if(s.at(i)==l.at(p)) {
            p++;
        }
        else p=0;
    }
    return false;
}

struct gen {
gen() {}
str s;
list<Data> dl;
};

gen generate(list<str> text,int times = 1)
{
list<list<str>> meta;
for(int i=0;i<text.length();i++) meta << newList(text[i]);


list<Data> finished;
for(int i=0;i<times;i++)
{
    Data s;
    for(auto l : meta) {
        if(l[0]!="X") {
            char delmiter = l[0].at(0);
            if(delmiter == '[')
            {
                auto sr = subParse(l[0]);
                if(sr.cmd=="RANDF")
                {
                    s.set<str>(l[1],std::to_string(randf(
                        std::stof(sr.lst[0]),
                        std::stof(sr.lst[1]))));
                }
                else if(sr.cmd=="RANDI")
                {
                    s.set<str>(l[1],std::to_string(randi(
                        std::stof(sr.lst[0]),
                        std::stof(sr.lst[1]))));
                }
                else
                {
                    s.set<str>(l[1],"INVALID OPPERATOR "+sr.cmd);
                }
            }
            else {
            str end = "";
            for(int c=2;c<l.length();c++)
            {
                auto nl = newList(l[c],delmiter);
                end = end+nl[randi(0,nl.length()-1)];
            }
            s.set<str>(l[1],end);
            }
        }
        else { 
            list<str> cl;
            for(int j=2;j<l.length();j++) {
                if(l[j].at(0)=='[')
                {
                    list<str> nsl = newList(l[j],']');
                    int isValid = 0;
                    for(int m=0;m<nsl.length();m++)
                    {
                        auto sr = subParse(nsl[m]);
                        if(sr.cmd=="ANY") {
                        if(s.has(sr.lst[0])) {
                                for(int c=1;c<sr.lst.length();c++) {
                                    if(sr.lst[c] == s.get<str>(sr.lst[0])) {
                                        isValid++;
                                        break;
                                    }
                                }
                            }
                        }
                        else if(sr.cmd=="REF") {
                        if(sr.lst.length()<=0)
                        {
                            print(nsl[m]);
                        }
                        else if(s.has(sr.lst[0])) {
                            str cbka = "";
                            auto cbkal = newList(sr.cbk,'[');
                            if(cbkal.length()>0) cbka = cbkal[0];
                            if(cl.length()==0) cl <<cbka+s.get<str>(sr.lst[0]);
                            else cl[0] = cl[0]+cbka+s.get<str>(sr.lst[0]);
                        }
                        }
                    }
                    if(isValid>=nsl.length()-1)
                    {
                        auto nnsl = newList(nsl[nsl.length()-1],'|');
                        cl << nnsl[randi(0,nnsl.length()-1)];
                    }
                    
                }
                else cl << l[j];
            }
            str toSet = "ERROR";
            if(cl.length()>0) toSet = cl[randi(0,cl.length()-1)];
            s.set<str>(l[1],toSet);}
         }
    finished << s;
}
str toReturn = "";
finished([&,meta](Data& s){
    for(int i=0;i<meta.length();i++) {if(meta[i][1].at(0)=='!') continue;
         else toReturn = toReturn+meta[i][1]+s.get<str>(meta[i][1])+"\n";}
    toReturn = toReturn+"----------------\n";
});
gen g;
g.dl = finished;
g.s = toReturn;
return g;
}


class T_Object : virtual public Object, virtual public Scriptable {
public:
    list<g_ptr<T_Object>> subs;
};
using SDC = g_ptr<d_list<g_ptr<T_Object>>>;
int main()
{
//Flipped a coin and OOP style won, so we're going with that
auto a = make<d_list<g_ptr<T_Object>>>();
for(size_t i=0;i<6;i++)
{
    auto t = make<T_Object>();
    gen name = generate(list<str>{
    "|,name,Ja|Be|Ma,ck |de |ly ,Smith|Klien|Mondelez|Ashford",
    });
    t->set<str>("name",name.dl[0].get<str>("name"));
    t->set<size_t>("id",i);
    t->set<SDC>("sdc",a);
    t->inc("hunger",randi(0,10));
    bool kind =  randf(0,1)>0.5f;
    t->set<bool>("kind",kind);
    bool evil =  randf(0,1)>0.5f;
    if(kind) evil = false;
    t->set<bool>("evil",evil);
    list<Data> f;
    for(int i=0;i<randi(0,3);i++)
    {
        Data food;
        food.inc<int>("sat",randi(1,3));
        bool deadly = randf(0,1)>0.5f;
        food.set<bool>("deadly",deadly);
        f << food;
    }
    t->set<list<Data>>("food",f);
    a->push(a);
}

for(auto t : (*a))
{
    list<Data> food = t->get<list<Data>>("food");
    if(t->inc("hunger",-1)>=6)
    {
        list<size_t> hungries;
        for(auto t2 : (*a))
        {
            if(t2->get<int>("hunger")<6) 
            {
                if(t2->get<list<Data>>("food").length()>0)
                    hungries << t2->get<size_t>("id");
            }
        }
        if(hungries.length()>0&&food.length()>0)
        {
            if(t->get<bool>("evil"))
            {
                int deadly = -1;
                for(int i=0;i<food.length();i++)
                {
                    if(food[i].get<bool>("deadly")) {deadly=i; break;}
                }
                if(deadly!=-1)
                {
                    g_ptr<T_Object> t2 = (*a)[hungries[randi(0,hungries.length()-1)]];
                    t2->get<list<Data>>("food") << food[deadly];
                    t->get<list<Data>>("food").removeAt(deadly);
                    print(t->get<str>("name")," gave a deadly food to ",t2->get<str>("name"));
                }
            }
            else if(t->get<bool>("kind"))
            {
                
            }
        }
    }
    else 
    {
        if(food.length()>0)
        {
            for(int i=0;i<food.length();i++)
            {
                if(!food[i].get<bool>("deadly"))
                {
                    print(t->get<str>("name")," ate some food");
                    int sat = food[i].get<int>("sat");
                    t->get<list<Data>>("food").removeAt(i);
                    t->inc("hunger",sat);
                    break;
                }
            }
        }
    }
}


return 0;
}