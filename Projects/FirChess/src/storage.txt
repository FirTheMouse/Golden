#include<core/helper.hpp>
#include<core/numGrid.hpp>
#include<util/meshBuilder.hpp>
#include<core/type.hpp>
#include<core/thread.hpp>
#include<util/logger.hpp>

using namespace Golden;

#define EVALUATE 0
#define LOG 0

g_ptr<Scene> scene = nullptr;
g_ptr<NumGrid> num_grid = nullptr;
bool debug_move = false;
bool free_camera = true;
bool bot_turn = false;

struct Move {
    int id, score;
    ivec2 from, to;
    int takes=-1;
    bool first_move = false;
    int opens_castle = -1;
    int rule = 0;
    
    int c_id = -1;
    ivec2 c_to,c_from;

    ivec2 e_square = {-1,-1};
    //0 == No rule
    //1 == Promotions
    //2 == Castling

    void saveBinary(std::ostream& out) const {
        out.write(reinterpret_cast<const char*>(&id), sizeof(int));
        out.write(reinterpret_cast<const char*>(&score), sizeof(int));
        out.write(reinterpret_cast<const char*>(&takes), sizeof(int));
        out.write(reinterpret_cast<const char*>(&first_move), sizeof(bool));
        out.write(reinterpret_cast<const char*>(&opens_castle), sizeof(int));
        out.write(reinterpret_cast<const char*>(&rule), sizeof(int));
        out.write(reinterpret_cast<const char*>(&c_id), sizeof(int));

        out.write(reinterpret_cast<const char*>(&from), sizeof(ivec2));
        out.write(reinterpret_cast<const char*>(&to), sizeof(ivec2));
        out.write(reinterpret_cast<const char*>(&c_to), sizeof(ivec2));
        out.write(reinterpret_cast<const char*>(&c_from), sizeof(ivec2));
        out.write(reinterpret_cast<const char*>(&e_square), sizeof(ivec2));      
    }

    void loadBinary(std::istream& in) {
        in.read(reinterpret_cast<char*>(&id), sizeof(int));
        in.read(reinterpret_cast<char*>(&score), sizeof(int));
        in.read(reinterpret_cast<char*>(&takes), sizeof(int));
        in.read(reinterpret_cast<char*>(&first_move), sizeof(bool));
        in.read(reinterpret_cast<char*>(&opens_castle), sizeof(int));
        in.read(reinterpret_cast<char*>(&rule), sizeof(int));
        in.read(reinterpret_cast<char*>(&c_id), sizeof(int));

        in.read(reinterpret_cast<char*>(&from), sizeof(ivec2));
        in.read(reinterpret_cast<char*>(&to), sizeof(ivec2));
        in.read(reinterpret_cast<char*>(&c_to), sizeof(ivec2));
        in.read(reinterpret_cast<char*>(&c_from), sizeof(ivec2));
        in.read(reinterpret_cast<char*>(&e_square), sizeof(ivec2));     
    }
};

list<Move> madeMoves;
map<uint64_t, Move> opening_book;

list<g_ptr<Single>> white_losses;
list<g_ptr<Single>> black_losses;

list<std::string> dtypes;
list<g_ptr<Single>> ref;
list<bool> captured;
list<int> colors;
list<int> values;
list<int> specialRules;
list<ivec2> cells;
list<list<ivec2>> moves;
list<bool> hasMoved;
Move last_move;
int white_king_id = -1;
int black_king_id = -1;
int white_queen_id = -1;
int black_queen_id = -1;
int white_rook_ids[2] = {-1,-1};
int black_rook_ids[2] = {-1,-1};

list<ivec2> white_pawn_moves;
list<ivec2> black_pawn_moves;
int pawn_value;
int pawn_specialRule;

ivec2 enpassant_square(-1,-1);
uint64_t en_passant_zobrist[8];

list<list<int>> grid;
list<list<int>> copyGrid() {
    return grid;
}

uint64_t zobrist_table[32][64];
uint64_t turn_zobrist_key;
uint64_t current_hash = 0;
map<uint64_t,int> history;

static constexpr uint64_t POLYGLOT_KEYS[781] = {
    0x9D39247E33776D41ULL, 0x2AF7398005AAA5C7ULL, 0x44DB015024623547ULL, 0x9C15F73E62A76AE2ULL,
    0x75834465489C0C89ULL, 0x3290AC3A203001BFULL, 0x0FBBAD1F61042279ULL, 0xE83A908FF2FB60CAULL,
    0x0D7E765D58755C10ULL, 0x1A083822CEAFE02DULL, 0x9605D5F0E25EC3B0ULL, 0xD021FF5CD13A2ED5ULL,
    0x40BDF15D4A672E32ULL, 0x011355146FD56395ULL, 0x5DB4832046F3D9E5ULL, 0x239F8B2D7FF719CCULL,
    0x05D1A1AE85B49AA1ULL, 0x679F848F6E8FC971ULL, 0x7449BBFF801FED0BULL, 0x7D11CDB1C3B7ADF0ULL,
    0x82C7709E781EB7CCULL, 0xF3218F1C9510786CULL, 0x331478F3AF51BBE6ULL, 0x4BB38DE5E7219443ULL,
    0xAA649C6EBCFD50FCULL, 0x8DBD98A352AFD40BULL, 0x87D2074B81D79217ULL, 0x19F3C751D3E92AE1ULL,
    0xB4AB30F062B19ABFULL, 0x7B0500AC42047AC4ULL, 0xC9452CA81A09D85DULL, 0x24AA6C514DA27500ULL,
    0x4C9F34427501B447ULL, 0x14A68FD73C910841ULL, 0xA71B9B83461CBD93ULL, 0x03488B95B0F1850FULL,
    0x637B2B34FF93C040ULL, 0x09D1BC9A3DD90A94ULL, 0x3575668334A1DD3BULL, 0x735E2B97A4C45A23ULL,
    0x18727070F1BD400BULL, 0x1FCBACD259BF02E7ULL, 0xD310A7C2CE9B6555ULL, 0xBF983FE0FE5D8244ULL,
    0x9F74D14F7454A824ULL, 0x51EBDC4AB9BA3035ULL, 0x5C82C505DB9AB0FAULL, 0xFCF7FE8A3430B241ULL,
    0x3253A729B9BA3DDEULL, 0x8C74C368081B3075ULL, 0xB9BC6C87167C33E7ULL, 0x7EF48F2B83024E20ULL,
    0x11D505D4C351BD7FULL, 0x6568FCA92C76A243ULL, 0x4DE0B0F40F32A7B8ULL, 0x96D693460CC37E5DULL,
    0x42E240CB63689F2FULL, 0x6D2BDCDAE2919661ULL, 0x42880B0236E4D951ULL, 0x5F0F4A5898171BB6ULL,
    0x39F890F579F92F88ULL, 0x93C5B5F47356388BULL, 0x63DC359D8D231B78ULL, 0xEC16CA8AEA98AD76ULL,
    0x5355F900C2A82DC7ULL, 0x07FB9F855A997142ULL, 0x5093417AA8A7ED5EULL, 0x7BCBC38DA25A7F3CULL,
    0x19FC8A768CF4B6D4ULL, 0x637A7780DECFC0D9ULL, 0x8249A47AEE0E41F7ULL, 0x79AD695501E7D1E8ULL,
    0x14ACBAF4777D5776ULL, 0xF145B6BECCDEA195ULL, 0xDABF2AC8201752FCULL, 0x24C3C94DF9C8D3F6ULL,
    0xBB6E2924F03912EAULL, 0x0CE26C0B95C980D9ULL, 0xA49CD132BFBF7CC4ULL, 0xE99D662AF4243939ULL,
    0x27E6AD7891165C3FULL, 0x8535F040B9744FF1ULL, 0x54B3F4FA5F40D873ULL, 0x72B12C32127FED2BULL,
    0xEE954D3C7B411F47ULL, 0x9A85AC909A24EAA1ULL, 0x70AC4CD9F04F21F5ULL, 0xF9B89D3E99A075C2ULL,
    0x87B3E2B2B5C907B1ULL, 0xA366E5B8C54F48B8ULL, 0xAE4A9346CC3F7CF2ULL, 0x1920C04D47267BBDULL,
    0x87BF02C6B49E2AE9ULL, 0x092237AC237F3859ULL, 0xFF07F64EF8ED14D0ULL, 0x8DE8DCA9F03CC54EULL,
    0x9C1633264DB49C89ULL, 0xB3F22C3D0B0B38EDULL, 0x390E5FB44D01144BULL, 0x5BFEA5B4712768E9ULL,
    0x1E1032911FA78984ULL, 0x9A74ACB964E78CB3ULL, 0x4F80F7A035DAFB04ULL, 0x6304D09A0B3738C4ULL,
    0x2171E64683023A08ULL, 0x5B9B63EB9CEFF80CULL, 0x506AACF489889342ULL, 0x1881AFC9A3A701D6ULL,
    0x6503080440750644ULL, 0xDFD395339CDBF4A7ULL, 0xEF927DBCF00C20F2ULL, 0x7B32F7D1E03680ECULL,
    0xB9FD7620E7316243ULL, 0x05A7E8A57DB91B77ULL, 0xB5889C6E15630A75ULL, 0x4A750A09CE9573F7ULL,
    0xCF464CEC899A2F8AULL, 0xF538639CE705B824ULL, 0x3C79A0FF5580EF7FULL, 0xEDE6C87F8477609DULL,
    0x799E81F05BC93F31ULL, 0x86536B8CF3428A8CULL, 0x97D7374C60087B73ULL, 0xA246637CFF328532ULL,
    0x043FCAE60CC0EBA0ULL, 0x920E449535DD359EULL, 0x70EB093B15B290CCULL, 0x73A1921916591CBDULL,
    0x56436C9FE1A1AA8DULL, 0xEFAC4B70633B8F81ULL, 0xBB215798D45DF7AFULL, 0x45F20042F24F1768ULL,
    0x930F80F4E8EB7462ULL, 0xFF6712FFCFD75EA1ULL, 0xAE623FD67468AA70ULL, 0xDD2C5BC84BC8D8FCULL,
    0x7EED120D54CF2DD9ULL, 0x22FE545401165F1CULL, 0xC91800E98FB99929ULL, 0x808BD68E6AC10365ULL,
    0xDEC468145B7605F6ULL, 0x1BEDE3A3AEF53302ULL, 0x43539603D6C55602ULL, 0xAA969B5C691CCB7AULL,
    0xA87832D392EFEE56ULL, 0x65942C7B3C7E11AEULL, 0xDED2D633CAD004F6ULL, 0x21F08570F420E565ULL,
    0xB415938D7DA94E3CULL, 0x91B859E59ECB6350ULL, 0x10CFF333E0ED804AULL, 0x28AED140BE0BB7DDULL,
    0xC5CC1D89724FA456ULL, 0x5648F680F11A2741ULL, 0x2D255069F0B7DAB3ULL, 0x9BC5A38EF729ABD4ULL,
    0xEF2F054308F6A2BCULL, 0xAF2042F5CC5C2858ULL, 0x480412BAB7F5BE2AULL, 0xAEF3AF4A563DFE43ULL,
    0x19AFE59AE451497FULL, 0x52593803DFF1E840ULL, 0xF4F076E65F2CE6F0ULL, 0x11379625747D5AF3ULL,
    0xBCE5D2248682C115ULL, 0x9DA4243DE836994FULL, 0x066F70B33FE09017ULL, 0x4DC4DE189B671A1CULL,
    0x51039AB7712457C3ULL, 0xC07A3F80C31FB4B4ULL, 0xB46EE9C5E64A6E7CULL, 0xB3819A42ABE61C87ULL,
    0x21A007933A522A20ULL, 0x2DF16F761598AA4FULL, 0x763C4A1371B368FDULL, 0xF793C46702E086A0ULL,
    0xD7288E012AEB8D31ULL, 0xDE336A2A4BC1C44BULL, 0x0BF692B38D079F23ULL, 0x2C604A7A177326B3ULL,
    0x4850E73E03EB6064ULL, 0xCFC447F1E53C8E1BULL, 0xB05CA3F564268D99ULL, 0x9AE182C8BC9474E8ULL,
    0xA4FC4BD4FC5558CAULL, 0xE755178D58FC4E76ULL, 0x69B97DB1A4C03DFEULL, 0xF9B5B7C4ACC67C96ULL,
    0xFC6A82D64B8655FBULL, 0x9C684CB6C4D24417ULL, 0x8EC97D2917456ED0ULL, 0x6703DF9D2924E97EULL,
    0xC547F57E42A7444EULL, 0x78E37644E7CAD29EULL, 0xFE9A44E9362F05FAULL, 0x08BD35CC38336615ULL,
    0x9315E5EB3A129ACEULL, 0x94061B871E04DF75ULL, 0xDF1D9F9D784BA010ULL, 0x3BBA57B68871B59DULL,
    0xD2B7ADEEDED1F73FULL, 0xF7A255D83BC373F8ULL, 0xD7F4F2448C0CEB81ULL, 0xD95BE88CD210FFA7ULL,
    0x336F52F8FF4728E7ULL, 0xA74049DAC312AC71ULL, 0xA2F61BB6E437FDB5ULL, 0x4F2A5CB07F6A35B3ULL,
    0x87D380BDA5BF7859ULL, 0x16B9F7E06C453A21ULL, 0x7BA2484C8A0FD54EULL, 0xF3A678CAD9A2E38CULL,
    0x39B0BF7DDE437BA2ULL, 0xFCAF55C1BF8A4424ULL, 0x18FCF680573FA594ULL, 0x4C0563B89F495AC3ULL,
    0x40E087931A00930DULL, 0x8CFFA9412EB642C1ULL, 0x68CA39053261169FULL, 0x7A1EE967D27579E2ULL,
    0x9D1D60E5076F5B6FULL, 0x3810E399B6F65BA2ULL, 0x32095B6D4AB5F9B1ULL, 0x35CAB62109DD038AULL,
    0xA90B24499FCFAFB1ULL, 0x77A225A07CC2C6BDULL, 0x513E5E634C70E331ULL, 0x4361C0CA3F692F12ULL,
    0xD941ACA44B20A45BULL, 0x528F7C8602C5807BULL, 0x52AB92BEB9613989ULL, 0x9D1DFA2EFC557F73ULL,
    0x722FF175F572C348ULL, 0x1D1260A51107FE97ULL, 0x7A249A57EC0C9BA2ULL, 0x04208FE9E8F7F2D6ULL,
    0x5A110C6058B920A0ULL, 0x0CD9A497658A5698ULL, 0x56FD23C8F9715A4CULL, 0x284C847B9D887AAEULL,
    0x04FEABFBBDB619CBULL, 0x742E1E651C60BA83ULL, 0x9A9632E65904AD3CULL, 0x881B82A13B51B9E2ULL,
    0x506E6744CD974924ULL, 0xB0183DB56FFC6A79ULL, 0x0ED9B915C66ED37EULL, 0x5E11E86D5873D484ULL,
    0xF678647E3519AC6EULL, 0x1B85D488D0F20CC5ULL, 0xDAB9FE6525D89021ULL, 0x0D151D86ADB73615ULL,
    0xA865A54EDCC0F019ULL, 0x93C42566AEF98FFBULL, 0x99E7AFEABE000731ULL, 0x48CBFF086DDF285AULL,
    0x7F9B6AF1EBF78BAFULL, 0x58627E1A149BBA21ULL, 0x2CD16E2ABD791E33ULL, 0xD363EFF5F0977996ULL,
    0x0CE2A38C344A6EEDULL, 0x1A804AADB9CFA741ULL, 0x907F30421D78C5DEULL, 0x501F65EDB3034D07ULL,
    0x37624AE5A48FA6E9ULL, 0x957BAF61700CFF4EULL, 0x3A6C27934E31188AULL, 0xD49503536ABCA345ULL,
    0x088E049589C432E0ULL, 0xF943AEE7FEBF21B8ULL, 0x6C3B8E3E336139D3ULL, 0x364F6FFA464EE52EULL,
    0xD60F6DCEDC314222ULL, 0x56963B0DCA418FC0ULL, 0x16F50EDF91E513AFULL, 0xEF1955914B609F93ULL,
    0x565601C0364E3228ULL, 0xECB53939887E8175ULL, 0xBAC7A9A18531294BULL, 0xB344C470397BBA52ULL,
    0x65D34954DAF3CEBDULL, 0xB4B81B3FA97511E2ULL, 0xB422061193D6F6A7ULL, 0x071582401C38434DULL,
    0x7A13F18BBEDC4FF5ULL, 0xBC4097B116C524D2ULL, 0x59B97885E2F2EA28ULL, 0x99170A5DC3115544ULL,
    0x6F423357E7C6A9F9ULL, 0x325928EE6E6F8794ULL, 0xD0E4366228B03343ULL, 0x565C31F7DE89EA27ULL,
    0x30F5611484119414ULL, 0xD873DB391292ED4FULL, 0x7BD94E1D8E17DEBCULL, 0xC7D9F16864A76E94ULL,
    0x947AE053EE56E63CULL, 0xC8C93882F9475F5FULL, 0x3A9BF55BA91F81CAULL, 0xD9A11FBB3D9808E4ULL,
    0x0FD22063EDC29FCAULL, 0xB3F256D8ACA0B0B9ULL, 0xB03031A8B4516E84ULL, 0x35DD37D5871448AFULL,
    0xE9F6082B05542E4EULL, 0xEBFAFA33D7254B59ULL, 0x9255ABB50D532280ULL, 0xB9AB4CE57F2D34F3ULL,
    0x693501D628297551ULL, 0xC62C58F97DD949BFULL, 0xCD454F8F19C5126AULL, 0xBBE83F4ECC2BDECBULL,
    0xDC842B7E2819E230ULL, 0xBA89142E007503B8ULL, 0xA3BC941D0A5061CBULL, 0xE9F6760E32CD8021ULL,
    0x09C7E552BC76492FULL, 0x852F54934DA55CC9ULL, 0x8107FCCF064FCF56ULL, 0x098954D51FFF6580ULL,
    0x23B70EDB1955C4BFULL, 0xC330DE426430F69DULL, 0x4715ED43E8A45C0AULL, 0xA8D7E4DAB780A08DULL,
    0x0572B974F03CE0BBULL, 0xB57D2E985E1419C7ULL, 0xE8D9ECBE2CF3D73FULL, 0x2FE4B17170E59750ULL,
    0x11317BA87905E790ULL, 0x7FBF21EC8A1F45ECULL, 0x1725CABFCB045B00ULL, 0x964E915CD5E2B207ULL,
    0x3E2B8BCBF016D66DULL, 0xBE7444E39328A0ACULL, 0xF85B2B4FBCDE44B7ULL, 0x49353FEA39BA63B1ULL,
    0x1DD01AAFCD53486AULL, 0x1FCA8A92FD719F85ULL, 0xFC7C95D827357AFAULL, 0x18A6A990C8B35EBDULL,
    0xCCCB7005C6B9C28DULL, 0x3BDBB92C43B17F26ULL, 0xAA70B5B4F89695A2ULL, 0xE94C39A54A98307FULL,
    0xB7A0B174CFF6F36EULL, 0xD4DBA84729AF48ADULL, 0x2E18BC1AD9704A68ULL, 0x2DE0966DAF2F8B1CULL,
    0xB9C11D5B1E43A07EULL, 0x64972D68DEE33360ULL, 0x94628D38D0C20584ULL, 0xDBC0D2B6AB90A559ULL,
    0xD2733C4335C6A72FULL, 0x7E75D99D94A70F4DULL, 0x6CED1983376FA72BULL, 0x97FCAACBF030BC24ULL,
    0x7B77497B32503B12ULL, 0x8547EDDFB81CCB94ULL, 0x79999CDFF70902CBULL, 0xCFFE1939438E9B24ULL,
    0x829626E3892D95D7ULL, 0x92FAE24291F2B3F1ULL, 0x63E22C147B9C3403ULL, 0xC678B6D860284A1CULL,
    0x5873888850659AE7ULL, 0x0981DCD296A8736DULL, 0x9F65789A6509A440ULL, 0x9FF38FED72E9052FULL,
    0xE479EE5B9930578CULL, 0xE7F28ECD2D49EECDULL, 0x56C074A581EA17FEULL, 0x5544F7D774B14AEFULL,
    0x7B3F0195FC6F290FULL, 0x12153635B2C0CF57ULL, 0x7F5126DBBA5E0CA7ULL, 0x7A76956C3EAFB413ULL,
    0x3D5774A11D31AB39ULL, 0x8A1B083821F40CB4ULL, 0x7B4A38E32537DF62ULL, 0x950113646D1D6E03ULL,
    0x4DA8979A0041E8A9ULL, 0x3BC36E078F7515D7ULL, 0x5D0A12F27AD310D1ULL, 0x7F9D1A2E1EBE1327ULL,
    0xDA3A361B1C5157B1ULL, 0xDCDD7D20903D0C25ULL, 0x36833336D068F707ULL, 0xCE68341F79893389ULL,
    0xAB9090168DD05F34ULL, 0x43954B3252DC25E5ULL, 0xB438C2B67F98E5E9ULL, 0x10DCD78E3851A492ULL,
    0xDBC27AB5447822BFULL, 0x9B3CDB65F82CA382ULL, 0xB67B7896167B4C84ULL, 0xBFCED1B0048EAC50ULL,
    0xA9119B60369FFEBDULL, 0x1FFF7AC80904BF45ULL, 0xAC12FB171817EEE7ULL, 0xAF08DA9177DDA93DULL,
    0x1B0CAB936E65C744ULL, 0xB559EB1D04E5E932ULL, 0xC37B45B3F8D6F2BAULL, 0xC3A9DC228CAAC9E9ULL,
    0xF3B8B6675A6507FFULL, 0x9FC477DE4ED681DAULL, 0x67378D8ECCEF96CBULL, 0x6DD856D94D259236ULL,
    0xA319CE15B0B4DB31ULL, 0x073973751F12DD5EULL, 0x8A8E849EB32781A5ULL, 0xE1925C71285279F5ULL,
    0x74C04BF1790C0EFEULL, 0x4DDA48153C94938AULL, 0x9D266D6A1CC0542CULL, 0x7440FB816508C4FEULL,
    0x13328503DF48229FULL, 0xD6BF7BAEE43CAC40ULL, 0x4838D65F6EF6748FULL, 0x1E152328F3318DEAULL,
    0x8F8419A348F296BFULL, 0x72C8834A5957B511ULL, 0xD7A023A73260B45CULL, 0x94EBC8ABCFB56DAEULL,
    0x9FC10D0F989993E0ULL, 0xDE68A2355B93CAE6ULL, 0xA44CFE79AE538BBEULL, 0x9D1D84FCCE371425ULL,
    0x51D2B1AB2DDFB636ULL, 0x2FD7E4B9E72CD38CULL, 0x65CA5B96B7552210ULL, 0xDD69A0D8AB3B546DULL,
    0x604D51B25FBF70E2ULL, 0x73AA8A564FB7AC9EULL, 0x1A8C1E992B941148ULL, 0xAAC40A2703D9BEA0ULL,
    0x764DBEAE7FA4F3A6ULL, 0x1E99B96E70A9BE8BULL, 0x2C5E9DEB57EF4743ULL, 0x3A938FEE32D29981ULL,
    0x26E6DB8FFDF5ADFEULL, 0x469356C504EC9F9DULL, 0xC8763C5B08D1908CULL, 0x3F6C6AF859D80055ULL,
    0x7F7CC39420A3A545ULL, 0x9BFB227EBDF4C5CEULL, 0x89039D79D6FC5C5CULL, 0x8FE88B57305E2AB6ULL,
    0xA09E8C8C35AB96DEULL, 0xFA7E393983325753ULL, 0xD6B6D0ECC617C699ULL, 0xDFEA21EA9E7557E3ULL,
    0xB67C1FA481680AF8ULL, 0xCA1E3785A9E724E5ULL, 0x1CFC8BED0D681639ULL, 0xD18D8549D140CAEAULL,
    0x4ED0FE7E9DC91335ULL, 0xE4DBF0634473F5D2ULL, 0x1761F93A44D5AEFEULL, 0x53898E4C3910DA55ULL,
    0x734DE8181F6EC39AULL, 0x2680B122BAA28D97ULL, 0x298AF231C85BAFABULL, 0x7983EED3740847D5ULL,
    0x66C1A2A1A60CD889ULL, 0x9E17E49642A3E4C1ULL, 0xEDB454E7BADC0805ULL, 0x50B704CAB602C329ULL,
    0x4CC317FB9CDDD023ULL, 0x66B4835D9EAFEA22ULL, 0x219B97E26FFC81BDULL, 0x261E4E4C0A333A9DULL,
    0x1FE2CCA76517DB90ULL, 0xD7504DFA8816EDBBULL, 0xB9571FA04DC089C8ULL, 0x1DDC0325259B27DEULL,
    0xCF3F4688801EB9AAULL, 0xF4F5D05C10CAB243ULL, 0x38B6525C21A42B0EULL, 0x36F60E2BA4FA6800ULL,
    0xEB3593803173E0CEULL, 0x9C4CD6257C5A3603ULL, 0xAF0C317D32ADAA8AULL, 0x258E5A80C7204C4BULL,
    0x8B889D624D44885DULL, 0xF4D14597E660F855ULL, 0xD4347F66EC8941C3ULL, 0xE699ED85B0DFB40DULL,
    0x2472F6207C2D0484ULL, 0xC2A1E7B5B459AEB5ULL, 0xAB4F6451CC1D45ECULL, 0x63767572AE3D6174ULL,
    0xA59E0BD101731A28ULL, 0x116D0016CB948F09ULL, 0x2CF9C8CA052F6E9FULL, 0x0B090A7560A968E3ULL,
    0xABEEDDB2DDE06FF1ULL, 0x58EFC10B06A2068DULL, 0xC6E57A78FBD986E0ULL, 0x2EAB8CA63CE802D7ULL,
    0x14A195640116F336ULL, 0x7C0828DD624EC390ULL, 0xD74BBE77E6116AC7ULL, 0x804456AF10F5FB53ULL,
    0xEBE9EA2ADF4321C7ULL, 0x03219A39EE587A30ULL, 0x49787FEF17AF9924ULL, 0xA1E9300CD8520548ULL,
    0x5B45E522E4B1B4EFULL, 0xB49C3B3995091A36ULL, 0xD4490AD526F14431ULL, 0x12A8F216AF9418C2ULL,
    0x001F837CC7350524ULL, 0x1877B51E57A764D5ULL, 0xA2853B80F17F58EEULL, 0x993E1DE72D36D310ULL,
    0xB3598080CE64A656ULL, 0x252F59CF0D9F04BBULL, 0xD23C8E176D113600ULL, 0x1BDA0492E7E4586EULL,
    0x21E0BD5026C619BFULL, 0x3B097ADAF088F94EULL, 0x8D14DEDB30BE846EULL, 0xF95CFFA23AF5F6F4ULL,
    0x3871700761B3F743ULL, 0xCA672B91E9E4FA16ULL, 0x64C8E531BFF53B55ULL, 0x241260ED4AD1E87DULL,
    0x106C09B972D2E822ULL, 0x7FBA195410E5CA30ULL, 0x7884D9BC6CB569D8ULL, 0x0647DFEDCD894A29ULL,
    0x63573FF03E224774ULL, 0x4FC8E9560F91B123ULL, 0x1DB956E450275779ULL, 0xB8D91274B9E9D4FBULL,
    0xA2EBEE47E2FBFCE1ULL, 0xD9F1F30CCD97FB09ULL, 0xEFED53D75FD64E6BULL, 0x2E6D02C36017F67FULL,
    0xA9AA4D20DB084E9BULL, 0xB64BE8D8B25396C1ULL, 0x70CB6AF7C2D5BCF0ULL, 0x98F076A4F7A2322EULL,
    0xBF84470805E69B5FULL, 0x94C3251F06F90CF3ULL, 0x3E003E616A6591E9ULL, 0xB925A6CD0421AFF3ULL,
    0x61BDD1307C66E300ULL, 0xBF8D5108E27E0D48ULL, 0x240AB57A8B888B20ULL, 0xFC87614BAF287E07ULL,
    0xEF02CDD06FFDB432ULL, 0xA1082C0466DF6C0AULL, 0x8215E577001332C8ULL, 0xD39BB9C3A48DB6CFULL,
    0x2738259634305C14ULL, 0x61CF4F94C97DF93DULL, 0x1B6BACA2AE4E125BULL, 0x758F450C88572E0BULL,
    0x959F587D507A8359ULL, 0xB063E962E045F54DULL, 0x60E8ED72C0DFF5D1ULL, 0x7B64978555326F9FULL,
    0xFD080D236DA814BAULL, 0x8C90FD9B083F4558ULL, 0x106F72FE81E2C590ULL, 0x7976033A39F7D952ULL,
    0xA4EC0132764CA04BULL, 0x733EA705FAE4FA77ULL, 0xB4D8F77BC3E56167ULL, 0x9E21F4F903B33FD9ULL,
    0x9D765E419FB69F6DULL, 0xD30C088BA61EA5EFULL, 0x5D94337FBFAF7F5BULL, 0x1A4E4822EB4D7A59ULL,
    0x6FFE73E81B637FB3ULL, 0xDDF957BC36D8B9CAULL, 0x64D0E29EEA8838B3ULL, 0x08DD9BDFD96B9F63ULL,
    0x087E79E5A57D1D13ULL, 0xE328E230E3E2B3FBULL, 0x1C2559E30F0946BEULL, 0x720BF5F26F4D2EAAULL,
    0xB0774D261CC609DBULL, 0x443F64EC5A371195ULL, 0x4112CF68649A260EULL, 0xD813F2FAB7F5C5CAULL,
    0x660D3257380841EEULL, 0x59AC2C7873F910A3ULL, 0xE846963877671A17ULL, 0x93B633ABFA3469F8ULL,
    0xC0C0F5A60EF4CDCFULL, 0xCAF21ECD4377B28CULL, 0x57277707199B8175ULL, 0x506C11B9D90E8B1DULL,
    0xD83CC2687A19255FULL, 0x4A29C6465A314CD1ULL, 0xED2DF21216235097ULL, 0xB5635C95FF7296E2ULL,
    0x22AF003AB672E811ULL, 0x52E762596BF68235ULL, 0x9AEBA33AC6ECC6B0ULL, 0x944F6DE09134DFB6ULL,
    0x6C47BEC883A7DE39ULL, 0x6AD047C430A12104ULL, 0xA5B1CFDBA0AB4067ULL, 0x7C45D833AFF07862ULL,
    0x5092EF950A16DA0BULL, 0x9338E69C052B8E7BULL, 0x455A4B4CFE30E3F5ULL, 0x6B02E63195AD0CF8ULL,
    0x6B17B224BAD6BF27ULL, 0xD1E0CCD25BB9C169ULL, 0xDE0C89A556B9AE70ULL, 0x50065E535A213CF6ULL,
    0x9C1169FA2777B874ULL, 0x78EDEFD694AF1EEDULL, 0x6DC93D9526A50E68ULL, 0xEE97F453F06791EDULL,
    0x32AB0EDB696703D3ULL, 0x3A6853C7E70757A7ULL, 0x31865CED6120F37DULL, 0x67FEF95D92607890ULL,
    0x1F2B1D1F15F6DC9CULL, 0xB69E38A8965C6B65ULL, 0xAA9119FF184CCCF4ULL, 0xF43C732873F24C13ULL,
    0xFB4A3D794A9A80D2ULL, 0x3550C2321FD6109CULL, 0x371F77E76BB8417EULL, 0x6BFA9AAE5EC05779ULL,
    0xCD04F3FF001A4778ULL, 0xE3273522064480CAULL, 0x9F91508BFFCFC14AULL, 0x049A7F41061A9E60ULL,
    0xFCB6BE43A9F2FE9BULL, 0x08DE8A1C7797DA9BULL, 0x8F9887E6078735A1ULL, 0xB5B4071DBFC73A66ULL,
    0x230E343DFBA08D33ULL, 0x43ED7F5A0FAE657DULL, 0x3A88A0FBBCB05C63ULL, 0x21874B8B4D2DBC4FULL,
    0x1BDEA12E35F6A8C9ULL, 0x53C065C6C8E63528ULL, 0xE34A1D250E7A8D6BULL, 0xD6B04D3B7651DD7EULL,
    0x5E90277E7CB39E2DULL, 0x2C046F22062DC67DULL, 0xB10BB459132D0A26ULL, 0x3FA9DDFB67E2F199ULL,
    0x0E09B88E1914F7AFULL, 0x10E8B35AF3EEAB37ULL, 0x9EEDECA8E272B933ULL, 0xD4C718BC4AE8AE5FULL,
    0x81536D601170FC20ULL, 0x91B534F885818A06ULL, 0xEC8177F83F900978ULL, 0x190E714FADA5156EULL,
    0xB592BF39B0364963ULL, 0x89C350C893AE7DC1ULL, 0xAC042E70F8B383F2ULL, 0xB49B52E587A1EE60ULL,
    0xFB152FE3FF26DA89ULL, 0x3E666E6F69AE2C15ULL, 0x3B544EBE544C19F9ULL, 0xE805A1E290CF2456ULL,
    0x24B33C9D7ED25117ULL, 0xE74733427B72F0C1ULL, 0x0A804D18B7097475ULL, 0x57E3306D881EDB4FULL,
    0x4AE7D6A36EB5DBCBULL, 0x2D8D5432157064C8ULL, 0xD1E649DE1E7F268BULL, 0x8A328A1CEDFE552CULL,
    0x07A3AEC79624C7DAULL, 0x84547DDC3E203C94ULL, 0x990A98FD5071D263ULL, 0x1A4FF12616EEFC89ULL,
    0xF6F7FD1431714200ULL, 0x30C05B1BA332F41CULL, 0x8D2636B81555A786ULL, 0x46C9FEB55D120902ULL,
    0xCCEC0A73B49C9921ULL, 0x4E9D2827355FC492ULL, 0x19EBB029435DCB0FULL, 0x4659D2B743848A2CULL,
    0x963EF2C96B33BE31ULL, 0x74F85198B05A2E7DULL, 0x5A0F544DD2B1FB18ULL, 0x03727073C2E134B1ULL,
    0xC7F6AA2DE59AEA61ULL, 0x352787BAA0D7C22FULL, 0x9853EAB63B5E0B35ULL, 0xABBDCDD7ED5C0860ULL,
    0xCF05DAF5AC8D77B0ULL, 0x49CAD48CEBF4A71EULL, 0x7A4C10EC2158C4A6ULL, 0xD9E92AA246BF719EULL,
    0x13AE978D09FE5557ULL, 0x730499AF921549FFULL, 0x4E4B705B92903BA4ULL, 0xFF577222C14F0A3AULL,
    0x55B6344CF97AAFAEULL, 0xB862225B055B6960ULL, 0xCAC09AFBDDD2CDB4ULL, 0xDAF8E9829FE96B5FULL,
    0xB5FDFC5D3132C498ULL, 0x310CB380DB6F7503ULL, 0xE87FBB46217A360EULL, 0x2102AE466EBB1148ULL,
    0xF8549E1A3AA5E00DULL, 0x07A69AFDCC42261AULL, 0xC4C118BFE78FEAAEULL, 0xF9F4892ED96BD438ULL,
    0x1AF3DBE25D8F45DAULL, 0xF5B4B0B0D2DEEEB4ULL, 0x962ACEEFA82E1C84ULL, 0x046E3ECAAF453CE9ULL,
    0xF05D129681949A4CULL, 0x964781CE734B3C84ULL, 0x9C2ED44081CE5FBDULL, 0x522E23F3925E319EULL,
    0x177E00F9FC32F791ULL, 0x2BC60A63A6F3B3F2ULL, 0x222BBFAE61725606ULL, 0x486289DDCC3D6780ULL,
    0x7DC7785B8EFDFC80ULL, 0x8AF38731C02BA980ULL, 0x1FAB64EA29A2DDF7ULL, 0xE4D9429322CD065AULL,
    0x9DA058C67844F20CULL, 0x24C0E332B70019B0ULL, 0x233003B5A6CFE6ADULL, 0xD586BD01C5C217F6ULL,
    0x5E5637885F29BC2BULL, 0x7EBA726D8C94094BULL, 0x0A56A5F0BFE39272ULL, 0xD79476A84EE20D06ULL,
    0x9E4C1269BAA4BF37ULL, 0x17EFEE45B0DEE640ULL, 0x1D95B0A5FCF90BC6ULL, 0x93CBE0B699C2585DULL,
    0x65FA4F227A2B6D79ULL, 0xD5F9E858292504D5ULL, 0xC2B5A03F71471A6FULL, 0x59300222B4561E00ULL,
    0xCE2F8642CA0712DCULL, 0x7CA9723FBB2E8988ULL, 0x2785338347F2BA08ULL, 0xC61BB3A141E50E8CULL,
    0x150F361DAB9DEC26ULL, 0x9F6A419D382595F4ULL, 0x64A53DC924FE7AC9ULL, 0x142DE49FFF7A7C3DULL,
    0x0C335248857FA9E7ULL, 0x0A9C32D5EAE45305ULL, 0xE6C42178C4BBB92EULL, 0x71F1CE2490D20B07ULL,
    0xF1BCC3D275AFE51AULL, 0xE728E8C83C334074ULL, 0x96FBF83A12884624ULL, 0x81A1549FD6573DA5ULL,
    0x5FA7867CAF35E149ULL, 0x56986E2EF3ED091BULL, 0x917F1DD5F8886C61ULL, 0xD20D8C88C8FFE65FULL,
    0x31D71DCE64B2C310ULL, 0xF165B587DF898190ULL, 0xA57E6339DD2CF3A0ULL, 0x1EF6E6DBB1961EC9ULL,
    0x70CC73D90BC26E24ULL, 0xE21A6B35DF0C3AD7ULL, 0x003A93D8B2806962ULL, 0x1C99DED33CB890A1ULL,
    0xCF3145DE0ADD4289ULL, 0xD0E4427A5514FB72ULL, 0x77C621CC9FB3A483ULL, 0x67A34DAC4356550BULL,
    0xF8D626AAAF278509ULL
};


#define TT_EXACT 0
#define TT_ALPHA 1
#define TT_BETA 2

struct TTEntry {
    uint64_t hash = 0;
    int depth = -1;
    int score = 0;
    int flag = 0; // 0=EXACT, 1=ALPHA, 2=BETA
    Move best_move;
    bool valid = false;
};

static const int TT_SIZE = 1024 * 1024; 
static TTEntry transposition_table[TT_SIZE];

uint64_t random64bit() {
    return ((uint64_t)rand() << 32) | rand();
}


void type_define_objects(g_ptr<NumGrid> level = nullptr,const std::string& project_name = "FirChess") {
    map<std::string,std::string> type_modelPath;

    auto is_model = [](const std::string& filename) -> std::string{ 
        auto split = split_str(filename,'.');
        if(split.length()>0)
        {
            if(split[split.length()-1]=="glb") {
                std::string toReturn = "";
                for(int i=0;i<split.length()-1;i++)
                {
                    toReturn.append(split[i]);
                }
                return toReturn;
            }
        }
        return "[NULL]";
    };

    auto process_files = [&is_model,&type_modelPath](const std::string& path) -> void{ 
        auto files = list_files(path);
        for(auto f : files)
        {
        list<std::string> split = split_str(f,'/');
        std::string filename = split[split.length()-1];
        std::string name = is_model(filename);
        if(name!="[NULL]") {
            type_modelPath.put(name,f);
        }
        }
    };

    std::function<void(const std::string&)> process_directory_recursive = [&](const std::string& path) -> void {
        process_files(path);
        auto subdirs = list_subdirectories(path, false);
        for(const auto& subdir : subdirs) {
            process_directory_recursive(subdir);
        }
    };
    process_directory_recursive("../Projects/"+project_name+"/assets/models/");

    std::string data_string = "NONE";
    try {
    data_string = readFile("../Projects/"+project_name+"/assets/models/"+project_name+" - data.csv");
    }
    catch(std::exception e)
    {
        print("No - data.csv provided for ",project_name," this is required for object definitions to work");
    }
    std::string cleaned_data = data_string;
    size_t pos = 0;
    while((pos = cleaned_data.find("\r\n", pos)) != std::string::npos) {
        cleaned_data.replace(pos, 2, "\n");
        pos += 1;
    }
    auto lines = split_str(cleaned_data, '\n');
    list<std::string> headers;
    list<std::string> types;
    for(int i=0;i<2;i++)
    {
        for(auto s : split_str(lines[i],',')) {
            if(i==0) {
                headers << s;
            }  
            else if(i==1) {
                types << s;
            }
        }
    }


    for(auto entry : type_modelPath.entrySet())
    {
        std::string type = entry.key;
        std::string path = entry.value;
        scene->set<g_ptr<Model>>("_"+type+"_model",make<Model>(path));
        
        Script<> make_part("make_"+type,[level,type,lines,headers,types](ScriptContext& ctx){
            auto model = scene->get<g_ptr<Model>>("_"+type+"_model");
            auto modelCopy = make<Model>();
            modelCopy->copy(*model);
            auto part = make<Single>(modelCopy);
            scene->add(part);

            for(int i=2;i<lines.length();i++)
            {
            list<std::string> values = split_str(lines[i],',');
            if(values[0]==type) {
                for(int t = 0;t<values.length();t++)
                {
                    std::string t_type = types[t];
                    if(values[t]=="") continue;
                    if(t_type=="string") part->add<std::string>(headers[t],values[t]);
                    else if (t_type=="int") part->add<int>(headers[t],std::stoi(values[t]));
                    else if (t_type=="float") part->add<float>(headers[t],std::stof(values[t]));
                    else if(t_type=="bool") part->add<bool>(headers[t],values[t]=="true"?1:0);
                    else if (t_type=="vec2list") {
                        list<ivec2> moves;
                        list<std::string> sub = split_str(values[t],'|');
                        for(int e = 0;e<sub.length();e++) {
                            list<std::string> sub_sub = split_str(sub[e],':');
                            ivec2 v(std::stof(sub_sub[0]),std::stof(sub_sub[1]));
                            moves << v;
                        }
                        part->add<list<ivec2>>(headers[t],moves);
                    }
                }
            }
            }

            if(level)
            {
                // part->setPosition(level->snapToGrid(scene->getMousePos()));
                // list<int> myCells = level->cellsAround(part->getPosition(),((part->model->localBounds.getSize().x-1)/2));
                // for(auto cell : myCells)
                // {
                //     grid->cells[cell].push(part->ID);
                // }
                // part->set<list<int>>("_cells",myCells);
            }
            ctx.set<g_ptr<Object>>("toReturn",part);
    });
    scene->define(type,make_part);
    }
}

bool isMultiple(ivec2 move, ivec2 pattern) {
    if(pattern.x() == 0 && pattern.y() == 0) return false;
    if(pattern.x() == 0) return move.x() == 0 && ((int)move.y()%(int)pattern.y()) == 0 && (move.y() / pattern.y()) > 0;
    if(pattern.y() == 0) return move.y() == 0 &&(int)move.x() % (int)pattern.x() == 0 && (move.x() / pattern.x()) > 0;
    return (int)move.x() % (int)pattern.x() == 0 && (int)move.y() % (int)pattern.y() == 0 && 
           (move.x() / pattern.x()) == (move.y() / pattern.y()) && (move.x() / pattern.x()) > 0;
}

int ctf(char c) {
    switch(c) {
        case 'h': return 1;
        case 'g': return 2;
        case 'f': return 3;
        case 'e': return 4;
        case 'd': return 5;
        case 'c': return 6;
        case 'b': return 7;
        case 'a': return 8;
        default: return 0;
    }
}

char file_to_char(int file) {
    switch(file) {
        case 1: return 'h';
        case 2: return 'g';
        case 3: return 'f';
        case 4: return 'e';
        case 5: return 'd';
        case 6: return 'c';
        case 7: return 'b';
        case 8: return 'a';
        default: return '\0';
    }
}

//Board to string
std::string bts(const ivec2& pos) {
    return file_to_char(pos.x())+std::to_string(pos.y());
}

//File = column, rank = row
vec3 board_to_world(int file, int rank) {
    return vec3((file-4)*2,0,(rank-4)*2);
}

vec3 board_to_world(char file, int rank) {
    return board_to_world(ctf(file),rank);
}

vec3 board_to_world(const ivec2& pos) {
    return board_to_world(int(pos.x()),int(pos.y()));
}

ivec2 world_to_board(const vec3& pos) {
    return ivec2((int)((pos.x()/2)+4),(int)((pos.z()/2)+4));
}

void update_num_grid(g_ptr<Single> selected,const vec3& pos) {
    num_grid->getCell(selected->getPosition()).erase(selected->ID);
    num_grid->getCell(pos) << selected->ID;
}

inline int& square(const ivec2& c) {
    return grid[c.x()][c.y()];
}

inline void update_grid(int id,const ivec2& to) {
    ivec2 from = cells[id];
    int old_square = (from.y() - 1) * 8 + (8-from.x());
    int new_square = (to.y() - 1) * 8 + (8-to.x());
    current_hash ^= zobrist_table[id][old_square];  // Remove from old square
    current_hash ^= zobrist_table[id][new_square];  // Add to new square


    square(cells[id]) = -1;
    square(to) = id;
    cells[id] = to;
}

//poached code from the Physics class meant to be use multi-threaded but just raw here
void update_physics() {
    //print(scene->active.length());
    for(int i=0;i<scene->active.length();i++) {
        if(scene->active[i]) {
            glm::mat4& transform = scene->transforms.get(i,"physics::141");
            Velocity& velocity = scene->velocities.get(i,"physics::142");
            float velocityScale = 1.0f;
            glm::vec3 pos = glm::vec3(transform[3]);
            pos += vec3(velocity.position * 0.016f * velocityScale).toGlm();
            transform[3] = glm::vec4(pos, 1.0f);
            glm::vec3 rotVel = vec3(velocity.rotation * 0.016f * velocityScale).toGlm();
            if (glm::length(rotVel) > 0.0001f) {
                glm::mat4 rotationDelta = glm::mat4(1.0f);
                rotationDelta = glm::rotate(rotationDelta, rotVel.y, glm::vec3(0, 1, 0)); // yaw
                rotationDelta = glm::rotate(rotationDelta, rotVel.x, glm::vec3(1, 0, 0)); // pitch
                rotationDelta = glm::rotate(rotationDelta, rotVel.z, glm::vec3(0, 0, 1));
                transform = transform * rotationDelta; // Apply rotation in object space
            }
            glm::vec3 scaleChange = vec3(velocity.scale * 0.016f * velocityScale).toGlm();
            if (glm::length(scaleChange) > 0.0001f) {
                glm::mat4 scaleDelta = glm::scale(glm::mat4(1.0f), glm::vec3(1.0f) + scaleChange);
                transform = transform * scaleDelta; // Apply after rotation
            }
        }
    }
    
}

// Piece to string
std::string pts(int id) {
    return dtypes[id]+"-"+std::to_string(id);
}

// Move to string
std::string mts(Move move) {
    return pts(move.id)+" from "+bts(move.from)+" to "+bts(move.to)+(move.takes!=-1?" takes "+pts(move.takes):"");
}

void print_move(Move move) {
    print(pts(move.id)," from ",bts(move.from)," to ",bts(move.to),move.takes!=-1?" takes "+pts(move.takes):"");
}


inline ivec2 pos_of(int piece) {
    return cells[piece];
}

vec3 world_pos_of(int piece) {
    return board_to_world(pos_of(piece));
}

bool in_bounds(const vec3& pos) {
    return(pos.x()<=8.0f&&pos.x()>=-6.0f&&pos.z()<=8.0f&&pos.z()>=-6.0f);
}

bool in_bounds(const ivec2& pos) {
    return(pos.x()<=8&&pos.x()>=1&&pos.y()<=8&&pos.y()>=1);
}

// int get_polyglot_piece_type(int your_piece_id) {
//     std::string piece_type = dtypes[your_piece_id];

//     if(piece_type == "pawn_white")   return 0;
//     if(piece_type == "knight_white") return 1;
//     if(piece_type == "bishop_white") return 2;
//     if(piece_type == "rook_white")   return 3;
//     if(piece_type == "queen_white")  return 4;
//     if(piece_type == "king_white")   return 5;

//     if(piece_type == "pawn_black")   return 6;
//     if(piece_type == "knight_black") return 7;
//     if(piece_type == "bishop_black") return 8;
//     if(piece_type == "rook_black")   return 9;
//     if(piece_type == "queen_black")  return 10;
//     if(piece_type == "king_black")   return 11;

//     return -1; // invalid
// }

int get_polyglot_piece_type(int your_piece_id) {
    std::string piece_type = dtypes[your_piece_id];
    
    // Python's piece order: (piece_type-1)*2 + color
    if(piece_type == "pawn_white") return 0;   // (1-1)*2 + 0
    if(piece_type == "pawn_black") return 1;   // (1-1)*2 + 1
    if(piece_type == "knight_white") return 2; // (2-1)*2 + 0  
    if(piece_type == "knight_black") return 3; // (2-1)*2 + 1
    if(piece_type == "bishop_white") return 4; // (3-1)*2 + 0
    if(piece_type == "bishop_black") return 5; // (3-1)*2 + 1
    if(piece_type == "rook_white") return 6;   // (4-1)*2 + 0
    if(piece_type == "rook_black") return 7;   // (4-1)*2 + 1
    if(piece_type == "queen_white") return 8;  // (5-1)*2 + 0
    if(piece_type == "queen_black") return 9;  // (5-1)*2 + 1
    if(piece_type == "king_white") return 10;  // (6-1)*2 + 0
    if(piece_type == "king_black") return 11;  // (6-1)*2 + 1
    
    return -1;
}

uint64_t hash_board() {
    uint64_t hash = 0;
    for(int piece = 0; piece < 32; piece++) {
        if(!captured[piece]) {
            ivec2 pos = pos_of(piece);
            int square = (pos.y() - 1) * 8 + (8-pos.x());
            hash ^= zobrist_table[piece][square];
        }
    }

    if(!hasMoved[white_king_id] && !hasMoved[white_rook_ids[1]]) {
        hash ^= POLYGLOT_KEYS[768]; // White kingside
    }
    if(!hasMoved[white_king_id] && !hasMoved[white_rook_ids[0]]) {
        hash ^= POLYGLOT_KEYS[769]; // White queenside  
    }
    if(!hasMoved[black_king_id] && !hasMoved[black_rook_ids[1]]) {
        hash ^= POLYGLOT_KEYS[770]; // Black kingside
    }
    if(!hasMoved[black_king_id] && !hasMoved[black_rook_ids[0]]) {
        hash ^= POLYGLOT_KEYS[771]; // Black queenside
    }
    
    // Hash en passant square
    if(enpassant_square.x() != -1) {
        int ep_file = 8-enpassant_square.x(); // Convert to 0-7
        hash ^= POLYGLOT_KEYS[772 + ep_file];
    }

    return hash;
}

uint64_t get_search_hash(int color) {
    uint64_t hash = current_hash;
    if(color == 0) hash ^= POLYGLOT_KEYS[780];
    return hash;
}


//This danmed zobrist hashing will be the death of me, I'll fiqure it out one day, then I'll have a nice opening book

// inline int poly_square(ivec2 pos) {
//     int file = 8 - pos.x();
//     int rank = pos.y() - 1;
//     return rank * 8 + file;
// }

// uint64_t core_hash(int color) {
//     uint64_t hash = 0;

//     static constexpr std::array<uint64_t, 16> CASTLING_KEY = []() {
//         std::array<uint64_t, 16> arr{};
//         for (int mask = 0; mask < 16; ++mask) {
//             uint64_t k = 0;
//             for (int i = 0; i < 4; ++i) {
//                 if (mask & (1 << i)) {
//                     k ^= POLYGLOT_KEYS[768 + i];
//                 }
//             }
//             arr[mask] = k;
//         }
//         return arr;
//     }();

//     for (int id = 0; id < 32; ++id) {
//         if (!captured[id]) {
//             int pt = get_polyglot_piece_type(id);
//             ivec2 pos = pos_of(id);
//             int sq = poly_square(pos); // your square mapping
//             uint64_t k = POLYGLOT_KEYS[64*pt + sq];
//             hash ^= k;
//             printf("step=%2d pt=%2d sq=%2d key=%016llx hash=%016llx\n",
//                 id, pt, sq, (unsigned long long)k, (unsigned long long)hash);
//                 int index = 64 * pt + sq;
//             printf("id=%d pt=%d sq=%d index=%d key=%016llx\n",
//                 id, pt, sq, index, POLYGLOT_KEYS[index]);
//         }
//     }

// //     int count[12] = {0};
// // for (int id=0; id<32; ++id) {
// //     if (!captured[id]) {
// //         int pt = get_polyglot_piece_type(id);
// //         count[pt]++;
// //     }
// // }
// // for (int pt=0; pt<12; ++pt)
// //     printf("pt=%d count=%d\n", pt, count[pt]);


   
    
//         // White O-O (kingside)
//     bool white_can_OO = 
//     !hasMoved[white_king_id] && 
//     !hasMoved[white_rook_ids[1]];

//     // White O-O-O (queenside)
//     bool white_can_OOO = 
//     !hasMoved[white_king_id] && 
//     !hasMoved[white_rook_ids[0]];

//     // Black O-O (kingside)
//     bool black_can_OO = 
//     !hasMoved[black_king_id] && 
//     !hasMoved[black_rook_ids[1]];

//     // Black O-O-O (queenside)
//     bool black_can_OOO = 
//     !hasMoved[black_king_id] && 
//     !hasMoved[black_rook_ids[0]];

//     int cr = 0;
//     if (white_can_OO)   cr |= 1;  // bit0
//     if (white_can_OOO)  cr |= 2;  // bit1
//     if (black_can_OO)   cr |= 4;  // bit2
//     if (black_can_OOO)  cr |= 8;  // bit3

//     hash ^= CASTLING_KEY[cr];

//     if (hash == 0x823C9B50FD114196ULL) {
//         printf("Piece-only hash matches!\n");
//     } else {
//         printf("Got %016llx, expected %016llx\n",
//                (unsigned long long)hash,
//                0x823C9B50FD114196ULL);
//     }

//     if(color == 0) hash ^= POLYGLOT_KEYS[780];

//     return hash;
// }

void setup_piece(const std::string& type,int file,int rank) {
    auto piece = scene->create<Single>(type);
    piece->setPosition(board_to_world(file,rank));
    ivec2 mySquare{file,rank};
    square(mySquare) = piece->ID;
    cells << mySquare;

    //update_cells(piece);
    std::string dtype = piece->get<std::string>("dtype");
    if(dtype=="king_white") white_king_id = dtypes.length();
    if(dtype=="king_black") black_king_id = dtypes.length();
    if(dtype=="queen_white") white_queen_id = dtypes.length();
    if(dtype=="queen_black") black_queen_id = dtypes.length();
    if(dtype=="rook_white") {
        if(white_rook_ids[0]==-1) white_rook_ids[0] = dtypes.length();
        else white_rook_ids[1] = dtypes.length();
    }
    if(dtype=="rook_black") {
        if(black_rook_ids[0]==-1) black_rook_ids[0] = dtypes.length();
        else black_rook_ids[1] = dtypes.length();
    }
    dtypes << dtype;
    colors << piece->get<int>("color");
    int value = piece->get<int>("value");
    values << value;
    int specialRule = piece->get<int>("specialRule");
    specialRules << specialRule;
    list<ivec2> n_moves = piece->get<list<ivec2>>("moves");
    moves << n_moves;
    captured << false;
    ref << piece;
    hasMoved << false;
    if(dtype=="pawn_black") {
        black_pawn_moves = n_moves;
        pawn_value = value;
        pawn_specialRule = specialRule;
    }
    if(dtype=="pawn_white") {
        white_pawn_moves = n_moves;
        pawn_value = value;
        pawn_specialRule = specialRule;
    }
}

int turn_color = 0; //0 = White, 1 = Black
g_ptr<Single> selected = nullptr;
int s_id = 0;
ivec2 start_pos(0,0);
list<g_ptr<Single>> drop;
long sleep_time = 0;

void select_piece(int id) {
    selected = ref[id];
    s_id = id;
    start_pos = pos_of(id);
}

void takePiece(int id,bool real = true) {
    //print(dtypes[id],"-",id," taken ");
    int color = colors[id];
    square(cells[id]) = -1;
    ivec2 pos = cells[id];
    int square_index = (pos.y() - 1) * 8 + (8-pos.x());
    current_hash ^= zobrist_table[id][square_index];
    captured[id] = true;
    if(color==0) {
        if(real) {
            ref[id]->setPosition(vec3(((int)white_losses.length()-6),1,-9));
            white_losses << ref[id];
        }
    } else if(color==1) {
        if(real) {
            ref[id]->setPosition(vec3(((int)black_losses.length()-6),1,11));
            black_losses << ref[id];
        }
    }
}

void promote(int id,bool real = true) {
    int q_id = colors[id]==0?white_queen_id:black_queen_id;
    moves[id] = moves[q_id];
    values[id] = values[q_id];
    specialRules[id] = specialRules[q_id];
    if(real) {
        ref[id]->setModel(ref[q_id]->model);
    }
}


void unpromote(int id,bool real = true) {
    moves[id] = colors[id]==0?white_pawn_moves:black_pawn_moves;
    values[id] = pawn_value;
    specialRules[id] = pawn_specialRule;
    if(real) {
        std::string type = colors[id]==0?"pawn_white":"pawn_black";
        ref[id]->setModel(scene->get<g_ptr<Model>>("_"+type+"_model"));
    }
}

void castle(Move& move,bool real = true) {
    int king_id = move.id;
    int rook_id = square(move.to);
    if(rook_id==-1) {
        // if(move.to==ivec2(8,8))
        //     rook_id = black_rook_ids[0];
        print("No rook for castle at square: ");
        move.to.print();
        // print(bts({8,8}));
        // print(square({8,8}));
        // print(bts({8,1}));
        // print(square({8,1}));
        // print(bts({1,8}));
        // print(square({1,8}));
        // print(bts({1,1}));
        // print(square({1,1}));
    }

    move.c_from = move.to;
    move.c_id = rook_id;

    ivec2 rook_pos = pos_of(rook_id);
    ivec2 king_pos = move.from;
    ivec2 dir = (rook_pos.x() > king_pos.x()) ? ivec2(1,0) : ivec2(-1,0);
    ivec2 new_king_pos = king_pos+(dir*2);
    move.to = new_king_pos;
    move.c_to = (new_king_pos-dir);
}

void makeMove(Move& move,bool real = true) {
    if(!hasMoved[move.id]) {
        move.first_move = true;
        hasMoved[move.id] = true;

        if(move.id == white_king_id) {
            current_hash ^= POLYGLOT_KEYS[768]; // White kingside
            current_hash ^= POLYGLOT_KEYS[769]; // White queenside
        }
        else if(move.id == black_king_id) {
            current_hash ^= POLYGLOT_KEYS[770]; // Black kingside  
            current_hash ^= POLYGLOT_KEYS[771]; // Black queenside
        }
        else if(move.id == white_rook_ids[0]) {
            current_hash ^= POLYGLOT_KEYS[769]; // White queenside
        }
        else if(move.id == white_rook_ids[1]) {
            current_hash ^= POLYGLOT_KEYS[768]; // White kingside
        }
        else if(move.id == black_rook_ids[0]) {
            current_hash ^= POLYGLOT_KEYS[771]; // Black queenside
        }
        else if(move.id == black_rook_ids[1]) {
            current_hash ^= POLYGLOT_KEYS[770]; // Black kingside
        }
    }
    if(move.rule != 2 || move.rule==4) {
        //Damned en passant...
        int t = move.rule==4?square(move.to-(colors[move.id]==0?ivec2(0,1):ivec2(0,-1))):square(move.to);
        if(t!=-1) {
            takePiece(t,real);
            move.takes = t;
        }
    }

    move.e_square = enpassant_square;

    if(enpassant_square.x() != -1) {
        current_hash ^= en_passant_zobrist[8-enpassant_square.x()];
    }
    
    //promotion
    if(move.rule == 1) {
        promote(move.id,real);
    } //castle
    else if(move.rule == 2) {
        if(move.c_id==-1)
            castle(move,real);
        Move linked;
        linked.from = move.c_from;
        linked.to = move.c_to;
        linked.id = move.c_id;
        makeMove(linked,real);
    } //Pawn double move
    
    if(move.rule == 3) {
        enpassant_square = move.to-(colors[move.id]==0?ivec2(0,1):ivec2(0,-1));
        current_hash ^= en_passant_zobrist[8-enpassant_square.x()];
    } else {
        enpassant_square = ivec2(-1,-1);
    }

    update_grid(move.id,move.to);
    if(real) {
        update_num_grid(ref[move.id],board_to_world(move.to));
        ref[move.id]->setPosition(board_to_world(move.to));
        history.getOrPut(current_hash,0)++;
        #if !EVALUATE
        print_move(move);
        #endif
    }

    // uint64_t hash_after = hash_board();
    // uint64_t expected_hash = current_hash;
    
    // if(hash_after != expected_hash) {
    //     print("Move caused hash mismatch:");
    //     print_move(move);
    //     print("Expected:", expected_hash, "Actual:", hash_after);
    // }
}

void unmakeMove(Move move,bool real = true) {
    if(move.first_move) {
        hasMoved[move.id] = false;
        if(move.id == white_king_id) {
            current_hash ^= POLYGLOT_KEYS[768]; // White kingside
            current_hash ^= POLYGLOT_KEYS[769]; // White queenside
        }
        else if(move.id == black_king_id) {
            current_hash ^= POLYGLOT_KEYS[770]; // Black kingside  
            current_hash ^= POLYGLOT_KEYS[771]; // Black queenside
        }
        else if(move.id == white_rook_ids[0]) {
            current_hash ^= POLYGLOT_KEYS[769]; // White queenside
        }
        else if(move.id == white_rook_ids[1]) {
            current_hash ^= POLYGLOT_KEYS[768]; // White kingside
        }
        else if(move.id == black_rook_ids[0]) {
            current_hash ^= POLYGLOT_KEYS[771]; // Black queenside
        }
        else if(move.id == black_rook_ids[1]) {
            current_hash ^= POLYGLOT_KEYS[770]; // Black kingside
        }
    }

    if(enpassant_square.x() != -1) {
        current_hash ^= en_passant_zobrist[8-enpassant_square.x()];
    }

    enpassant_square = move.e_square;

    if(enpassant_square.x() != -1) {
        current_hash ^= en_passant_zobrist[8-enpassant_square.x()];
    }

    //promotion
    if(move.rule == 1) {
        unpromote(move.id,real);
    }
    else if(move.rule == 2) {
        Move linked;
        linked.from = move.c_from;
        linked.to = move.c_to;
        linked.id = move.c_id;
        linked.first_move = true;
        unmakeMove(linked,real);
    }


    update_grid(move.id,move.from);
    if(real) {
        update_num_grid(ref[move.id],board_to_world(move.from));
        ref[move.id]->setPosition(board_to_world(move.from));
        #if !EVALUATE
        print("Unmade move: "); print_move(move);
        #endif
    } 

    ivec2 return_to = move.to;
    if(move.rule==4) {
        return_to = move.to-(colors[move.id]==0?ivec2(0,1):ivec2(0,-1));
    }
    if(move.takes!=-1) {
        captured[move.takes] = false;
        int new_square = (return_to.y() - 1) * 8 + (8-return_to.x());
        current_hash ^= zobrist_table[move.takes][new_square];
        square(cells[move.takes]) = -1;
        square(return_to) = move.takes;
        //update_grid(move.takes,move.to);
        if(real) {
            update_num_grid(ref[move.takes],board_to_world(return_to));
            ref[move.takes]->setPosition(board_to_world(return_to));
        }
    }

    if(real) {
        history.get(current_hash)--;
    }
}

void save_game(const std::string& file) {
    std::string path = "../Projects/FirChess/assets/games/"+file+".gdc";
    std::ofstream out(path, std::ios::binary);
    if (!out) throw std::runtime_error("Can't write to file: " + path);
    out.write(reinterpret_cast<const char*>(&turn_color), sizeof(turn_color));
    out.write(reinterpret_cast<const char*>(&current_hash), sizeof(current_hash));
    uint32_t moveLen = madeMoves.length();
    out.write(reinterpret_cast<const char*>(&moveLen), sizeof(moveLen));
    for (const auto& m : madeMoves) {
        m.saveBinary(out);
    }
    out.close();
}

void load_game(const std::string& file) {
    std::string path = "../Projects/FirChess/assets/games/"+file+".gdc";
    std::ifstream in(path, std::ios::binary);
    if (!in) throw std::runtime_error("Can't read from file: " + path);
    in.read(reinterpret_cast<char*>(&turn_color), sizeof(turn_color));
    in.read(reinterpret_cast<char*>(&current_hash), sizeof(current_hash));
    uint32_t moveLen;
    in.read(reinterpret_cast<char*>(&moveLen), sizeof(moveLen));
    madeMoves.clear();
    for (uint32_t i = 0; i < moveLen; ++i) {
        Move m;
        m.loadBinary(in);
        makeMove(m);
        madeMoves << m;
    }
    in.close();
}

bool can_attack(const ivec2& pos,int by_color) {
    //Looking at all the attack moves that can be made
    for(int i=(by_color==0?0:16);i<(by_color==0?16:32);i++) {
        if(captured[i]) continue;
        ivec2 place = pos_of(i);
        int rule = specialRules[i];
        if(rule==1) {
            ivec2 d_r = ivec2(1,moves[i][0].y());
            ivec2 d_l = ivec2(-1,moves[i][0].y());
            if((d_r+place)==pos) return true;
            if((d_l+place)==pos) return true;
        } 
        else if(rule==2) {
            for(int m=0;m<moves[i].length();m++) {
                for(int d=1;d<=7;d++) {
                    ivec2 dir = moves[i][m]*d;
                    if((place+dir)==pos) return true;
                    vec3 nPos = board_to_world(place+dir);
                    if(!in_bounds(place+dir)) break;
                    if(square(place+dir)!=-1) { //Raycasting
                        break;
                    }
                }
            }
        }
        else { //Normal moves only, because all special rules cover attacks they can do
            for(auto v : moves[i]) {
                if((place+v)==pos) return true;
            }
        }
    }
    return false;
}

bool isKingInCheck(int color) {
    if(can_attack(pos_of(color==0?white_king_id:black_king_id),1-color)) 
        return true;
    return false;
}

list<int> is_attacking(const ivec2& pos,int by_color) {
    //Looking at all the attack moves that can be made
    list<int> result;
    for(int i=(by_color==0?0:16);i<(by_color==0?16:32);i++) {
        if(captured[i]) continue;
        ivec2 place = pos_of(i);
        int rule = specialRules[i];
        if(rule==1) {
            ivec2 d_r = ivec2(1,moves[i][0].y());
            ivec2 d_l = ivec2(-1,moves[i][0].y());
            if((d_r+place)==pos)  result << i;
            if((d_l+place)==pos)  result << i;
        } 
        else if(rule==2) {
            for(int m=0;m<moves[i].length();m++) {
                for(int d=1;d<=7;d++) {
                    ivec2 dir = moves[i][m]*d;
                    if((place+dir)==pos) {result << i; break;}
                    vec3 nPos = board_to_world(place+dir);
                    if(!in_bounds(place+dir)) break;
                    if(square(place+dir)!=-1) { //Raycasting
                        break;
                    }
                }
            }
        }
        else { //Normal moves only, because all special rules cover attacks they can do
            for(auto v : moves[i]) {
                if((place+v)==pos) {result << i; break;}
            }
        }
    }
    return result;
}

int basic_capture_value(Move move,int color) {
    int gain = values[move.takes]; 
    makeMove(move, false);
    if(can_attack(move.to, 1-color)) {
        gain -= values[move.id];
    }
    unmakeMove(move, false);
    return gain;
}

int capture_value(Move move,int color) {
    int gain = values[move.takes]; 
    makeMove(move, false);
    auto attackers = is_attacking(move.to, 1-color);
    if(!attackers.empty()) {
        int cheapest_attacker = attackers[0];
        for(int attacker : attackers) {
            if(values[attacker] < values[cheapest_attacker]) {
                cheapest_attacker = attacker;
            }
        }
        gain -= values[move.id];

        auto counter_attackers = is_attacking(move.to, color);
        if(!counter_attackers.empty()) {
            gain += values[cheapest_attacker];
        }
    }
    unmakeMove(move, false);
    return gain;
}

bool validate_castle(int id,const ivec2& to) {
    int color = colors[id];
    if(hasMoved[id]) return false;
    if(id==(color==0?white_king_id:black_king_id)) {
        //This is just for fun, there's way more efficent ways to do this... 
        //but none cooler!
        if(square(to)==color==0?white_rook_ids[0]:black_rook_ids[0]||
           square(to)==color==0?white_rook_ids[1]:black_rook_ids[1])
            {
            int rook_id = square(to);
            if(hasMoved[rook_id]) return false;
            ivec2 king_pos = cells[id];
            ivec2 rook_pos = cells[rook_id];
            ivec2 dir = (rook_pos.x() > king_pos.x()) ? ivec2(1,0) : ivec2(-1,0);
            int start = std::min(king_pos.x(), rook_pos.x()) + 1;
            int end = std::max(king_pos.x(), rook_pos.x());
            
            for(int file = start; file < end; file++) {
                ivec2 check_pos(file, king_pos.y());
                if(square(check_pos)!=-1) 
                    return false;
                // Also checking check
                if(can_attack(check_pos, 1-color)) {
                    return false; 
                }
            }
            //Can't castle in check!
            if(can_attack(king_pos, 1-color)) {
                return false; 
            }
            
            return true;
        }
    }
    return false;
}

bool validate_move(Move& move) {
    if(!in_bounds(move.to)) return false;
    ivec2 pattern = (move.to-move.from);
    int color = colors[move.id];
    bool can_take = true;
      int rule = specialRules[move.id];
      bool validMove = false;
      for(auto m : moves[move.id]) {
          bool meets_special = false;
          switch(rule) {
              case 2: //Sliding
                  if(isMultiple(pattern, m)) meets_special = true;
              break;
              case 1: //Pawn
              {
                  can_take = false;
                  ivec2 d_l = ivec2(-1,m.y());
                  if(d_l == pattern) {
                      if(square(start_pos+d_l)!=-1) {
                          if(colors[square(start_pos+d_l)]!=color) {
                              meets_special=true;
                              can_take = true;
                          }
                      }
                  }
                 ivec2 d_r = ivec2(1,m.y());
                  if(d_r == pattern) {
                      if(square(start_pos+d_r)!=-1) {
                          if(colors[square(start_pos+d_r)]!=color) {
                              meets_special=true;
                              can_take = true;
                          }
                      }
                  }

                  if(enpassant_square!=ivec2(-1,-1)) {
                    if(move.to==enpassant_square) {
                        meets_special = true;
                        can_take = true;
                        move.rule = 4;
                    } 
                }

                  if(!hasMoved[s_id]) {
                      if(ivec2(0,color==1?-2:2)==pattern) {
                          move.rule = 3;
                          meets_special=true;
                      }
                  } 
              }
              break;
              case 0:
              default: 
              meets_special = false;
          }

          if(pattern == m || meets_special) {
            if(square(move.to)!=-1) {
                if(can_take&&colors[square(move.to)]!=colors[s_id]) {
                    // print(dtypes[s_id]," takes ",dtypes[square(to)]);
                        validMove = true;
                    }
            }
            else {
               validMove = true;
            }
        }
      }
    if(!validMove) return false;    
    return true;
}

Move decode_polyglot_move(uint16_t encoded_move) {
    int from_square = encoded_move & 0x3F;        // Bottom 6 bits
    int to_square = (encoded_move >> 6) & 0x3F;   // Next 6 bits
    int promotion = (encoded_move >> 12) & 0x7;   // Next 3 bits
    
    // Convert 0-63 square to your ivec2 format
    ivec2 from(8 - (from_square % 8), (from_square / 8) + 1);
    ivec2 to(8 - (to_square % 8), (to_square / 8) + 1);
    
    // Find which piece is at the from square
    int piece_id = square(from);
    if(piece_id == -1) return Move(); // Invalid
    
    Move move;
    move.id = piece_id;
    move.from = from;
    move.to = to;
    
    if(promotion > 0) move.rule = 1; // Promotion
    
    return move;
}

void load_opening_book() {
    std::string path = "../Projects/FirChess/assets/games/Perfect2023.bin";
    std::ifstream in(path, std::ios::binary);
    if (!in) throw std::runtime_error("Can't read from file: " + path);
    int fails = 0;
    while(in) {
        uint64_t hash;
        uint16_t move, weight, learn;
        
        // Read the 16-byte entry
        in.read(reinterpret_cast<char*>(&hash), 8);
        in.read(reinterpret_cast<char*>(&move), 2);
        in.read(reinterpret_cast<char*>(&weight), 2);
        in.read(reinterpret_cast<char*>(&learn), 2);
        in.seekg(2, std::ios::cur); // Skip 2 bytes padding
 
        if(in.gcount() > 0) { // Successfully read data
            Move decoded_move = decode_polyglot_move(move);
            if(decoded_move.id != -1) {
                // makeMove(decoded_move,false);
                // unmakeMove(decoded_move,false);
                // if(!validate_move(decoded_move)) print("Failed to validate ",mts(decoded_move));
                opening_book.getOrPut(hash,decoded_move);
               // print("Loaded: ",mts(decoded_move));
            } else fails++;
        }
    }
    in.close();
    print("Loaded ", opening_book.size(), " opening positions, ",fails," failed to load");
}


bool check_promotion(Move& move) {
    if(specialRules[move.id]==1) {
        int color = colors[move.id];
        float promotion_rank = color==0?8:1;
        if(move.to.y()==promotion_rank) {
            return true;
        }
    }
    return false;
}

list<ivec2> can_castle(int color) {
    list<ivec2> result;
    if(hasMoved[color==0?white_king_id:black_king_id]) return result;
    int side = -1;
    ivec2 king_pos = pos_of(color==0?white_king_id:black_king_id);
    for(int i=0;i<2;i++) {
        if(!hasMoved[color==0?white_rook_ids[i]:black_rook_ids[i]]
            &&!captured[color==0?white_rook_ids[i]:black_rook_ids[i]]) {
            ivec2 rook_pos = pos_of(color==0?white_rook_ids[i]:black_rook_ids[i]);
            ivec2 dir = (rook_pos.x() > king_pos.x()) ? ivec2(1,0) : ivec2(-1,0);
            //bool is_long = king_pos.x()<rook_pos.x();
            int start = std::min(king_pos.x(), rook_pos.x()) + 1;
            int end = std::max(king_pos.x(), rook_pos.x());
            bool valid = true;
            if(can_attack(king_pos, 1-color)) {
                valid = false;
            }
            else {
                for(int file = start; file < end; file++) {
                    ivec2 check_pos(file, king_pos.y());
                    if(square(check_pos)!=-1) {
                        valid = false;
                        break;
                    }
                    // Also checking check
                    if(can_attack(check_pos, 1-color)) {
                        valid = false; 
                        break;
                    }
                }
            }

            if(valid) {
                result << (rook_pos-king_pos);
            }
        }
    }
    return result;
}

list<Move> generateMoves(int color) {
    // Line total;
    // total.start();
    // Line s;
    // s.start();
    list<Move> result;
    //if(captured[color==0?white_king_id:black_king_id]) return result;
    for(int i=(color==0?0:16);i<(color==0?16:32);i++) {
        // Line inner;
        // inner.start();
        bool castling = false;
        if(captured[i]) continue;
        select_piece(i);
        list<ivec2> special_moves;
        if(specialRules[i]==1) {
            ivec2 d_r = ivec2(1,moves[i][0].y());
            ivec2 d_l = ivec2(-1,moves[i][0].y());
            if(square(start_pos+moves[i][0])==-1) { 
                ivec2 dd_m = ivec2(0,colors[i]==0?2:-2);
                special_moves << dd_m;
            }
            special_moves << d_r;
            special_moves << d_l;
            if(enpassant_square!=ivec2(-1,-1)) {
                if(d_r==enpassant_square) {
                    special_moves << d_r;
                } 
                if(d_l==enpassant_square) {
                    special_moves << d_l;
                }
            }
        } 
        else if(specialRules[i]==2) {
            for(int m=0;m<moves[i].length();m++) {
                for(int d=1;d<=7;d++) {
                    ivec2 dir = moves[i][m]*d;
                    if(!in_bounds(start_pos+dir)) break;
                    if(square(start_pos+dir)!=-1) {
                        if(colors[square(start_pos+dir)]!=color) {
                            special_moves << dir;
                        }
                        break;
                    }
                    special_moves << dir;
                }
            }
        }
        if(i==(colors[i]==0?white_king_id:black_king_id)) {
            list<ivec2> side = can_castle(color);
            if(!side.empty()) {
                castling = true;
                for(auto s : side) {
                    special_moves << s;
                }
            }
        }

        if(specialRules[i]!=2) //Don't evaluate normal moves for sliding peices
        for(int m=0;m<moves[i].length();m++) {
            Move move;
            move.id = s_id;
            move.from = start_pos;
            move.to = start_pos+moves[i][m];
            if(validate_move(move)) {
                result << move;
            }
        }
        for(int m=0;m<special_moves.length();m++) {
            Move move;
            move.id = s_id;
            move.from = start_pos;
            move.to = start_pos+special_moves[m];
            if(specialRules[s_id]==1) {
                ivec2 dd_m = ivec2(0,colors[i]==0?2:-2);
                if(special_moves[m]==dd_m) {
                    move.rule = 3;
                }
            }
            if(castling) move.rule = 2;
            if(validate_move(move)||castling) {
                result << move;
            }
        }
        //print(dtypes[i]," time ",inner.end());
        selected = nullptr;
    }
    // print("Loop time ",s.end());
    // s.start();
    list<Move> good_captures;
    list<Move> neutral_captures; 
    list<Move> bad_captures;
    list<Move> quiet_moves;
    for(auto& m : result) {
        // print_move(m);
        makeMove(m, false);
        bool kingInCheck = isKingInCheck(color);
        unmakeMove(m, false);
        if(!kingInCheck) {
            if(check_promotion(m)) m.rule = 1;
            if(m.takes==-1) 
                quiet_moves << m;
            else {
                int cap_val = capture_value(m, color);
                m.score = cap_val;
                if(cap_val >= 200) good_captures << m;
                else if(cap_val >= 0) neutral_captures << m;
                else bad_captures << m;
            }
        }
    }
    std::sort(good_captures.begin(), good_captures.end(), [](Move& a, Move& b) {
        return a.score > b.score;
    });
    good_captures << neutral_captures << quiet_moves << bad_captures;
   
    // print("Final time ",s.end());
    // print("Total time ",total.end());
    return good_captures;
}

int getPositionalValue(int pieceId) {
    if(captured[pieceId]) return 0;
    
    ivec2 pos = pos_of(pieceId);
    int file = pos.x() - 1; // Convert to 0-7
    int rank = pos.y() - 1; // Convert to 0-7
    int color = colors[pieceId];
    
    // Flip for black pieces (they see board upside-down)
    if(color == 1) rank = 7 - rank;
    
    std::string piece = dtypes[pieceId];
    int bonus = 0;
    
    if(piece.find("pawn") != std::string::npos) {
        // Pawn table: advance = good, center files = good
        int pawn_table[8][8] = {
            { 0,  0,  0,  0,  0,  0,  0,  0},
            { 5, 10, 10,-20,-20, 10, 10,  5},
            { 5, -5,-10,  0,  0,-10, -5,  5},
            { 0,  0,  0, 20, 20,  0,  0,  0},
            { 5,  5, 10, 25, 25, 10,  5,  5},
            {10, 10, 20, 30, 30, 20, 10, 10},
            {50, 50, 50, 50, 50, 50, 50, 50},
            { 0,  0,  0,  0,  0,  0,  0,  0}
        };
        bonus = pawn_table[rank][file];
    }
    else if(piece.find("knight") != std::string::npos) {
        // Knights love the center, hate the rim
        int knight_table[8][8] = {
            {-50,-40,-30,-30,-30,-30,-40,-50},
            {-40,-20,  0,  0,  0,  0,-20,-40},
            {-30,  0, 10, 15, 15, 10,  0,-30},
            {-30,  5, 15, 20, 20, 15,  5,-30},
            {-30,  0, 15, 20, 20, 15,  0,-30},
            {-30,  5, 10, 15, 15, 10,  5,-30},
            {-40,-20,  0,  5,  5,  0,-20,-40},
            {-50,-40,-30,-30,-30,-30,-40,-50}
        };
        bonus = knight_table[rank][file];
    }
    
    return bonus;
}

int evaluateKingSafety(int color) {    
    ivec2 kingPos = pos_of(color==0?white_king_id:black_king_id);
    int safety = 100; // Start with base safety score
    
    // Check 3x3 area around king
    for(int df = -1; df <= 1; df++) {
        for(int dr = -1; dr <= 1; dr++) {
            if(df == 0 && dr == 0) continue; // Skip king's own square
            
            int checkFile = kingPos.x() + df;
            int checkRank = kingPos.y() + dr;
            
            if(checkFile < 1 || checkFile > 8 || checkRank < 1 || checkRank > 8) continue;
            
            ivec2 checkPos(checkFile, checkRank);
            
            if(square(checkPos)!=-1) {
                if(colors[square(checkPos)] == color) {
                    safety += 15; // Friendly defender nearby
                    
                    // Extra bonus for pawn shield
                    if(dtypes[square(checkPos)].find("pawn") != std::string::npos) {
                        safety += 25; // Pawn shields are extra valuable
                    }
                } else {
                    safety -= 20; // Enemy piece nearby is dangerous
                }
            } else {
                safety -= 10; // Empty squares around king = exposed
            }
        }
    }
    
    // Penalty for being in check
    if(isKingInCheck(color)) {
        safety -= 50;
    }
    
    return safety;
}

int evaluate() {  // 0 = white, 1 = black
    int score = 0;
    for(int i = 0; i < 32; i++) {
        if(!captured[i]) {
            int piece_value = values[i] + getPositionalValue(i);
            
            if(colors[i] == 0) {
                score += piece_value;
            } else {
                score -= piece_value;
            }
        }
    }

    score += evaluateKingSafety(0);
    score -= evaluateKingSafety(1);

    return score;
}

static int tt_hits = 0;
static int tt_misses = 0;

void test_hash_consistency() {
    uint64_t hash1 = current_hash;
    uint64_t hash2 = hash_board();
    if(hash1 != hash2) {
        print("HASH MISMATCH! Incremental:", hash1, "Recalc:", hash2);
    }
}

int tt_lookup(uint64_t hash, int depth, int alpha, int beta) {
    TTEntry& entry = transposition_table[hash % TT_SIZE];
    
    if(!entry.valid || entry.hash != hash) {
        tt_misses++;
        return INT_MIN;
    }
    
    if(entry.depth >= depth) {
        tt_hits++;
        if(entry.flag == TT_EXACT) {
            return entry.score;
        }
        if(entry.flag == TT_ALPHA && entry.score <= alpha) {
            return entry.score;
        }
        if(entry.flag == TT_BETA && entry.score >= beta) {
            return entry.score;
        }
    }
    tt_misses++;
    return INT_MIN;
}

void tt_store(uint64_t hash, int depth, int score, int flag) {
    TTEntry& entry = transposition_table[hash % TT_SIZE];
    
    if(!entry.valid || entry.depth <= depth) {
        entry.hash = hash;
        entry.depth = depth;
        entry.score = score;
        entry.flag = flag;
        entry.valid = true;
    }
}

void test_opening_book(int color) {
    uint64_t h = get_search_hash(color);
    if(opening_book.hasKey(h)) {
        Move book_move = opening_book.get(h);
        print("Opening book found move!!!!! ");
        print_move(book_move);
    } 
}

static int max_depth = 4;
#define ENABLE_AB 1
#define ENABLE_TT 1
#define ENABLE_PENALTY 1
#define ENABLE_TACTEXT 1
static int calcs = 0;
int minimax(int depth, int current_turn, int alpha, int beta) {
    if(depth == 0) return evaluate();
    test_hash_consistency();
    test_opening_book(current_turn);
    #if ENABLE_TT
    uint64_t hash = get_search_hash(current_turn);
    int tt_score = tt_lookup(hash, depth, alpha, beta);
    if(tt_score != INT_MIN) {
        return tt_score;
    }
    #endif

    auto moves = generateMoves(current_turn);
    if(moves.empty()) return evaluate();
    calcs+=2;
    if(current_turn == 0) {  // White maximizes
        int maxEval = -9999;
        int original_alpha = alpha;
        for(auto move : moves) {
            #if EVALUATE
            makeMove(move, true);
            if(current_turn==0&&depth>1)
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
            int eval = minimax(depth-1, 1-current_turn, alpha, beta);
            unmakeMove(move, true);
            #else
            int extension = 0;
            #if ENABLE_TACTEXT
            if(move.takes != -1 && depth < max_depth+1) {
                int cap_val = capture_value(move, current_turn);
                if(cap_val > 200) {
                    extension = 1;
                }
            }
            #endif
            makeMove(move, false);
            #if ENABLE_PENALTY
            int repeats = history.getOrDefault(current_hash,1)-1;
            int penalty = 50 * (repeats * repeats);
            #endif
            int eval = minimax(depth+extension-1, 1-current_turn, alpha, beta);
            #if ENABLE_PENALTY
            eval -= penalty;
            #endif
            unmakeMove(move, false);
            #endif
            
            maxEval = std::max(maxEval, eval);
            #if ENABLE_AB
            alpha = std::max(alpha, eval);
            if(alpha >= beta) break;
            #endif
        }
        #if ENABLE_TT
        int flag = TT_EXACT;
        if(maxEval <= original_alpha) flag = TT_ALPHA;
        if(maxEval >= beta) flag = TT_BETA;
        
        tt_store(hash, depth, maxEval, flag);
        #endif
        return maxEval;
    } else {  // Black minimizes
        int minEval = 9999;
        int original_beta = beta;
        for(auto move : moves) {
            #if EVALUATE
            makeMove(move, true);
            if(current_turn==1&&depth>1)
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
            int eval = minimax(depth-1, 1-current_turn, alpha, beta);
            unmakeMove(move, true);
            #else
            int extension = 0;
            #if ENABLE_TACTEXT
            if(move.takes != -1 && depth < max_depth+1) {
                int cap_val = capture_value(move, current_turn);
                if(cap_val > 200) {
                    extension = 1;
                }
            }
            #endif
            makeMove(move, false);
            #if ENABLE_PENALTY
            int repeats = history.getOrDefault(current_hash,1)-1;
            int penalty = 50 * (repeats * repeats);
            #endif
            int eval = minimax(depth+extension-1, 1-current_turn, alpha, beta);
            #if ENABLE_PENALTY
            eval += penalty;
            #endif
            unmakeMove(move, false);
            #endif
            
            minEval = std::min(minEval, eval);
            #if ENABLE_AB
            beta = std::min(beta, eval);
            if(alpha >= beta) break;
            #endif
        }
        #if ENABLE_TT
        int flag = TT_EXACT;
        if(minEval >= original_beta) flag = TT_BETA;
        if(minEval <= alpha) flag = TT_ALPHA;
        
        tt_store(hash, depth, minEval, flag);
        #endif
        return minEval;
    }
}

Move findBestMove(int depth,int color) {
    Line s; s.start();
    auto moves = generateMoves(color);
    if(moves.empty()) print("Out of moves");
    Move bestMove;
    bestMove.id = -1;
    int bestScore = color == 0 ? -9999 : 9999;
    list<Move> equal_moves;
    bool new_equal = false;
    tt_hits = 0;
    tt_misses = 0;
    #if LOG
    print("-----Finding move for ",color==0?"white":"black","-----");
    #endif
    int alpha = -9999;
    int beta = 9999;
    for(auto& move : moves) {
        makeMove(move,false);
        int repeats = history.getOrDefault(current_hash,1)-1;
        int penalty = 50 * (repeats * repeats);
        int score = minimax(depth-1, 1-color, alpha, beta);
        if(color == 0) {
            score -= penalty;
        } else {
            score += penalty;
        }
        if(penalty>50) print(mts(move)," Score: ",score);
        move.score = score;
        unmakeMove(move,false);
        calcs+=2;
        
        
        bool isBetter = color == 0 ? (score > bestScore) : (score < bestScore);
        if(isBetter) {
            bestScore = score;
            #if LOG
            print("New best: ",bestScore);
            print_move(move);
            #endif
            bestMove = move;
            new_equal = true;
        } else if (score==bestScore) {
            if(new_equal) {
                new_equal = false;
                equal_moves.clear();
                equal_moves << bestMove;
            }
            equal_moves << move;
        }

        if(color == 0) {
            alpha = std::max(alpha, score);
        } else {
            beta = std::min(beta, score);
        }
        
       if(alpha >= beta) break;
    }
    if(bestMove.id==-1) {
        print("Checkmate!");
        return bestMove;
    }

    if(!equal_moves.empty()) {
        //bestMove = equal_moves[randi(0,equal_moves.length()-1)];
    }
    #if LOG
    print("From depth: ",depth," Calcs performed: ",calcs," time: ",s.end()/1000000000,"s Moves: ",equal_moves.length()," Chosen score: ",bestMove.score);
    #if ENABLE_TT
    print("TT hits: ", tt_hits, " misses: ", tt_misses, " hit rate: ", (float)tt_hits/(tt_hits+tt_misses));
    #endif
    #endif
    calcs = 0;
    return bestMove;
}


int main() {
    using namespace helper;
    std::string MROOT = "../Projects/FirChess/assets/models/";

    Window window = Window(1280, 768, "FirChess 0.9.5");
    scene = make<Scene>(window,2);
    scene->camera.toOrbit();
    //scene->camera.lock = true;
    Data d = make_config(scene,K);
    load_gui(scene, "FirChess", "firchessgui.fab");

    num_grid = make<NumGrid>(2.0f,21.0f);
    
    //Define the objects, this pulls in the models and uses the CSV to code them
    type_define_objects(num_grid);

    for(int a=0;a<9;a++) {
        grid << list<int>();
        for(int b=0;b<9;b++) {
            grid[a] << -1;
        }
    }

    for(int k = 0;k<2;k++) {
    std::string col = k==0?"white":"black";
    int rank = k==0?1:8;
        setup_piece("queen_"+col,ctf('d'),rank);
        for(int i=0;i<2;i++) setup_piece("bishop_"+col,ctf(i==0?'c':'f'),rank);
        for(int i=0;i<2;i++) setup_piece("rook_"+col,ctf(i==0?'a':'h'),rank);
        for(int i=0;i<2;i++) setup_piece("knight_"+col,ctf(i==0?'b':'g'),rank);
        for(int i=1;i<9;i++) setup_piece("pawn_"+col,i,k==0?2:7);
        setup_piece("king_"+col,ctf('e'),rank);
    }

    for(int piece = 0; piece < 32; piece++) {
        for(int square = 0; square < 64; square++) {
            int polyglot_piece = get_polyglot_piece_type(piece);
            zobrist_table[piece][square] = POLYGLOT_KEYS[polyglot_piece * 64 + square];
        }
    }
    
    for(int i = 0; i < 8; i++) {
        en_passant_zobrist[i] = POLYGLOT_KEYS[772 + i];
    }
    turn_zobrist_key = POLYGLOT_KEYS[780];
    current_hash = hash_board();
    for(int i = 0; i < TT_SIZE; i++) {
        transposition_table[i].valid = false;
    }

    //For loading autosaved games
    //load_game("auto");
    load_opening_book();

    //Make the chess board and offset it so it works with the grid
    auto board = make<Single>(scene->get<g_ptr<Model>>("_board_model"));
    scene->add(board);
    board->move(vec3(1,-1.3,1));


    //Setting up the lighting, ticking environment to 0 just makes it night
    scene->tickEnvironment(0);
    auto l1 = make<Light>(Light(glm::vec3(0,10,0),glm::vec4(300,300,300,1)));
    scene->lights.push_back(l1);
    // auto l2 = make<Light>(Light(glm::vec3(-15,10,0),glm::vec4(500,500,500,1)));
    // scene->lights.push_back(l2);
   // Move bot_move;

    bool bot_color = 0;
    //Make the little mouse to reperesnt the bot (Fir!)
    auto Fir = make<Single>(make<Model>("../models/agents/Snow.glb"));
    scene->add(Fir);
    Fir->setPosition(bot_color==0?vec3(1,-1,-9):vec3(1,-1,11));
    if(bot_color==1) Fir->faceTo(vec3(0,-1,0));
    auto bot = make<Thread>();
    bot->run([&](ScriptContext& ctx){
        if(turn_color==bot_color) {
            bot_turn = true;
            save_game("auto");
            Move m = findBestMove(max_depth,turn_color);
            if(m.id!=-1) {
                makeMove(m);
                madeMoves << m;
                turn_color = turn_color==0?1:0;
            }
            else
                bot->pause();
            bot_turn = false;
        }
        //std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    },0.02f);

    auto phys_thread = make<Thread>();
    phys_thread->run([&](ScriptContext& ctx){
        update_physics();
    },0.016);
    phys_thread->start();

    bool auto_turn = true;
    if(auto_turn) bot->start();
    int last_col = turn_color;

// uint64_t starting_hash = core_hash(0); // White to move
// print("Starting position hash: 0x", std::hex, starting_hash);

    start::run(window,d,[&]{
        vec3 mousePos = scene->getMousePos(0);
        if(mousePos.x()>8.0f) mousePos.setX(8.0f);
        if(mousePos.x()<-6.0f) mousePos.setX(-6.0f);
        if(mousePos.z()>8.0f) mousePos.setZ(8.0f);
        if(mousePos.z()<-6.0f) mousePos.setZ(-6.0f);

        if(last_col!=turn_color) {
            text::setText(turn_color==0?"White":"Black",scene->getSlot("turn")[0]);
        }
        last_col = turn_color;

        if(!free_camera) {
            scene->camera.setTarget(vec3(1,-1,1));
            if(turn_color==1) {
                scene->camera.setPosition(vec3(1,20,15));
            }
            else if(turn_color==0) {
                scene->camera.setPosition(vec3(1,20,-14));
            }
        }
        if(pressed(SPACE)) turn_color = turn_color==0?1:0;
       
        if(pressed(I)) {
            if(debug_move) {print("Debug move off"); debug_move=false;}
            else {print("Debug move on"); debug_move=true;}
        } 
        if(pressed(C)) {
            if(free_camera){print("Locked camera"); scene->camera.lock = true; free_camera=false;}
            else{print("Free camera"); scene->camera.lock = false; free_camera=true;}
        }
        if(pressed(T)) {
            if(held(LSHIFT)) {
                //generateMoves(turn_color);
                if(!auto_turn) {auto_turn = true; print("Auto turn");}
                else {auto_turn=false; print("Disabled auto turn");}
            }
            else {
                Move m = findBestMove(max_depth,turn_color);
                if(m.id!=-1) {
                    makeMove(m);
                    madeMoves << m;
                }
            }
        }
        if(pressed(Y)) {
            vec3 clickPos = num_grid->snapToGrid(scene->getMousePos());
            if(in_bounds(world_to_board(clickPos)))
                if(square(world_to_board(clickPos))!=-1)
                    takePiece(square(world_to_board(clickPos)));
        }
        if(pressed(R)) if(!madeMoves.empty()) unmakeMove(madeMoves.pop());
        if(pressed(NUM_1)) scene->camera.toOrbit();
        if(pressed(NUM_2)) scene->camera.toIso();
        if(pressed(NUM_3)) scene->camera.toFirstPerson();

        if(pressed(E)) {
            auto clickPos = num_grid->snapToGrid(scene->getMousePos());
            ivec2 v = world_to_board(clickPos);
            if(in_bounds(v)) {
            //grid->toIndex(clickPos)
            print("----",bts(v),"----");
           if(square(v)!=-1) {
                print("E:",dtypes[square(v)]," I:",square(v));
           }
           else print("EMPTY");
            }
        }
        if(pressed(G)) {
            print(isKingInCheck(turn_color)==0?"No check":"In check");
        }
        if(pressed(MOUSE_LEFT)) {
            if(!selected) {
                 auto clickPos = num_grid->snapToGrid(scene->getMousePos());
                 ivec2 v = world_to_board(clickPos);
                if(in_bounds(v))
                if(square(v)!=-1) {
                    int t_s_id = square(v);
                     if(auto g = ref[t_s_id]) {
                        if(colors[t_s_id]==turn_color||debug_move) {
                         select_piece(t_s_id);
                         start_pos = world_to_board(clickPos);
                        }
                     }
                 }
             }
             else
             {
              //End the move here
              vec3 newPos = num_grid->snapToGrid(mousePos).addY(selected->getPosition().y());
              ivec2 v = world_to_board(newPos);
              if(in_bounds(v))
              {
              update_num_grid(selected,newPos);
              bool castling = false;
              if(validate_castle(s_id,v)) {
                castling = true;
              } 
              Move move;
              move.id = s_id;
              move.from = start_pos;
              move.to = v;
              if(castling) move.rule = 2;
              if(validate_move(move)||debug_move||castling) {
                makeMove(move,false);
                if(isKingInCheck(turn_color)) {
                    unmakeMove(move,false);
                    selected->setPosition(board_to_world(start_pos));
                }
                else {
                    unmakeMove(move,false);
                    if(check_promotion(move)) {
                        move.rule = 1;
                    }
                    makeMove(move);
                    //print("Move repeated: ",history.getOrDefault(current_hash,0));
                    madeMoves << move;
                    if(auto_turn) {
                        turn_color = 1-turn_color;
                    }
                }
              }
              else 
                selected->setPosition(board_to_world(start_pos));

              selected->setLinearVelocity(vec3(0,-2.5f,0));
              drop << selected;
              //print("Moving ",selected->ID," to "); v.print();
              //update_grid(selected->ID,v);
              selected = nullptr;
             }
            }
         }

         if(selected&&!bot_turn)
         {
            vec3 targetPos = num_grid->snapToGrid(mousePos).addY(1);
            vec3 direction = targetPos - selected->getPosition();
            float distance = direction.length();
            float moveSpeed = distance>=6.0f?distance*2:6.0f;
            if (distance > 0.1f) {
                selected->setLinearVelocity((direction / vec3(distance,distance,distance)) * moveSpeed);
            } else {
                selected->setLinearVelocity(vec3(0,0,0));
            }
         }

         for(auto d : drop) {
            if(d->getPosition().y()<=0) {
                d->setLinearVelocity(vec3(0,0,0)); 
                drop.erase(d);
            }
         }

         if(pressed(Q)) {
            if(held(LSHIFT)) unmakeMove(last_move);
            else {
                if(bot->runningTurn) {bot->pause(); bot_turn=false;}
                else {bot->start();}
            }
        }

        if(pressed(P)) {
            if(phys_thread->runningTurn) {phys_thread->pause();}
            else {phys_thread->start();}
        }

    });

return 0;
}