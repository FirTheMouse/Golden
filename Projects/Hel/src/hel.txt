
#include<util/meshBuilder.hpp>
#include<rendering/scene.hpp>
#include<util/color.hpp>
#include<extension/physics.hpp>
#include<hel/hel_sim.hpp>
#include<hel/hel_grid.hpp>
#include<hel/hel_scene.hpp>
#include<hel/hel_object.hpp>

using namespace Golden;

vec3 input2D()
{
    float x = 0.0f;
    float y = 0.0f;
    float z = 0.0f;
    Input& input = Input::get();

    if(input.keyPressed(UP)) z-=0.3f;
    if(input.keyPressed(DOWN)) z+=0.3f;
    if(input.keyPressed(LEFT)) x-=0.3f;
    if(input.keyPressed(RIGHT)) x+=0.3f;
    return vec3(x,y,z);
}

vec2 inputMove(float s)
{
    float x = 0.0f;
    float z = 0.0f;
    Input& input = Input::get();

    if(input.keyPressed(W)) z-=1.0f;
    if(input.keyPressed(S)) z+=1.0f;
    if(input.keyPressed(A)) x-=1.0f;
    if(input.keyPressed(D)) x+=1.0f;
    return vec2(x*s,z*s);
}

struct S_Tool
{
    float tpf = 0.1; float frametime = 0; int frame = 0;
    std::chrono::steady_clock::time_point last = std::chrono::high_resolution_clock::now();
    int frames = 0;
    float pause = 0.0f;

    void tick() {
        auto end = std::chrono::high_resolution_clock::now();
        auto delta = std::chrono::duration<float>(end - last);
        tpf = delta.count(); last = end; frame++; frames++;
        frametime+=tpf; frame++;
        if(frametime>=1) {
            std::cout << frames << " FPS" << std::endl;
            frametime=0;
            frames=0;
        }
    }
};

void SimSpeedControl()
{
    static bool deBounceSpace = false;
    if(Input::get().keyPressed(SPACE)&&!deBounceSpace) {T_Sim::get().setSpeed(0); P_Sim::get().setSpeed(0); deBounceSpace=true;}
    if(!Input::get().keyPressed(SPACE)&&deBounceSpace) {deBounceSpace = false;}
    if(Input::get().keyPressed(NUM_1)) T_Sim::get().setSpeed(0.3f);
    if(Input::get().keyPressed(NUM_2)) T_Sim::get().setSpeed(0.1f);
    if(Input::get().keyPressed(NUM_3)) T_Sim::get().setSpeed(0.03f);
    if(Input::get().keyPressed(NUM_4)) T_Sim::get().setSpeed(0.016f);
    if(Input::get().keyPressed(NUM_5)) T_Sim::get().setSpeed(0.001f);
}

int main()
{
    std::string ROOT = "../Projects/Hel/storage/";
    std::string GROOT = "../Projects/Hel/assets/gui/";
    std::string MROOT = "../Projects/Hel/models/";

    Window window = Window(1280, 768, "Hel 0.0.1");
    glfwSwapInterval(0); //Vsync 1=on 0=off
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cerr << "Failed to initialize GLAD" << std::endl;
        return 0;
    }
    glEnable(GL_DEPTH_TEST);
    glfwSetInputMode((GLFWwindow*)window.getWindow(), GLFW_CURSOR, GLFW_CURSOR_DISABLED);

    // map<int,float> t;
    // for(int i=0;i<100;i++) {t.put(i,randf(0.0f,10.0f));}
    // t.getAll()([&](float f){print(f);});



    float cellSize = 1.0f;
    float mapSize = 100.0f;

    g_ptr<H_Grid> grid = make<H_Grid>(
        cellSize,
        mapSize,
        makeTerrainGrid(mapSize,cellSize)
    );
    grid->intializeGrid();

    g_ptr<Hel> hel = make<Hel>(window,2);
    hel->tickEnvironment(1100);
    hel->setupShadows();
    hel->camera.speedMod = 0.01f;
    hel->camera.toFirstPerson();
    S_Tool s_tool;
    hel->add(grid);


    // Q_Fab ammo_counter_fab(GROOT+"ammo_counter.fab");
    // auto ammo_counter = guim->loadFab(ammo_counter_fab);

    hel->loadQFabList(GROOT+"helgui.fab");
    list<std::string> needed{"ammo_counter","health_bar"};
    for(auto s : needed)
        if(!hel->hasSlot(s)) print("hel::main::121 Missing GUI element: ",s);
    
    auto ammo_counter =hel->getSlot("ammo_counter")[0];
    //if(guim->hasSlot("ammo_counter")) guim->getSlot("ammo_counter");

    auto l1 = make<Light>(Light(glm::vec3(0,18,0),glm::vec4(600,300,300,1)));
    hel->lights.push_back(l1);

    // for(int i =0; i<30;i++)
    // {
    // auto thing = make<H_Object>(make<Model>(makeTestBox(0.5f)));
    // thing->set<str>("dtype","thing");
    // hel->add(thing);
    // thing->setPosition(vec3(randf(-10,10),1,randf(-10,10)));
    // }

    auto one = make<H_Object>(make<Model>(MROOT+"one.glb"));
    one->set<str>("dtype","human");
    one->set<int>("hp",500);
    hel->add(one);
    one->setPhysicsState(P_State::ACTIVE);
    one->setPosition(vec3(0,1.22f,0));
    one->updateCells();
    one->addScript("onTick",[hel,one](ScriptContext& ctx){
        // one->setLinearVelocity(input2D().mult(16.0f));
    });
    one->addScript("onCollide",[hel,one](ScriptContext& ctx){
        g_ptr<S_Object> s = ctx.get<g_ptr<S_Object>>("with");
        //print(s->get<str>("dtype"));
        // Velocity v = hel->velocities[s->ID];
        // one->setVelocity(v);
    });

    one->addScript("onHit",[hel,one](ScriptContext& ctx){
        print("HIT!");
        auto g = hel->getSlot("health_bar")[0];
        //g->moveToAnim(vec3(g->getPosition().setY(1536-one->inc("hp",-ctx.get<int>("damage"))),0),0.01f);
        g->setPosition(g->getPosition().setY(1536-one->inc("hp",-ctx.get<int>("damage"))));
    });
    auto hbar = hel->getSlot("health_bar")[0];
    hbar->setPosition(hbar->getPosition().setY(1536-one->inc("hp",0)));

    auto gun = make<H_Object>(make<Model>(MROOT+"testgun.glb"));
    gun->set<str>("dtype","weapon");
    gun->set<int>("max_ammo",8);
    hel->add(gun);
    gun->setPhysicsState(P_State::NONE);
    gun->inc("ammo",gun->get<int>("max_ammo"));
    gun->addScript("onFire",[gun,hel](ScriptContext& ctx){
        if(gun->get<int>("ammo")>0)
        {
        auto g =hel->getSlot("ammo_counter")[0];
        text::setTextBefore(std::to_string(gun->inc<int>("ammo",-1)),'/',g);
        text::setTextAfter(std::to_string(gun->get<int>("max_ammo")),'/',g);
        }
    });

    auto g =hel->getSlot("ammo_counter")[0];
    text::setTextBefore(std::to_string(gun->inc<int>("ammo",0)),'/',ammo_counter);
    text::setTextAfter(std::to_string(gun->get<int>("max_ammo")),'/',ammo_counter);

    // auto spin = make<H_Object>(make<Model>(makeBox(1.0f,0.5f,0.5f,Color::RED)));
    // spin->set<str>("dtpye","hazard");
    // hel->add(spin);
    // spin->setPosition(vec3(0,0.5f,-3));
    // spin->addScript("onTick",[hel,spin](ScriptContext& ctx){
    //     int r = spin->inc("r",12);
    //     spin->rotate(r,vec3(0,1,0));
    // });

    // auto spin = make<H_Object>(make<Model>(makeBox(3.0f,0.5f,0.5f,Color::RED)));
    // spin->set<str>("dtype","hazard");
    // hel->add(spin);
    // spin->setPosition(vec3(0,0.5f,-3));
    // spin->setPhysicsState(P_State::ACTIVE);
    // Velocity v;
    // v.rotation = vec3(0,8,0);
    // spin->setVelocity(v);

    // spin->addScript("onCollide",[hel,spin](ScriptContext& ctx){
    //     g_ptr<S_Object> s = ctx.get<g_ptr<S_Object>>("with");
    //      print(s->get<str>("dtype"));
    // });
    
    auto main = make<H_Object>(make<Model>(MROOT+"main.glb"));
    hel->add(main);
    //test->setPosition(vec3(0,2,10));

    T_Sim::get().setScene(hel);
    P_Sim::get().setScene(hel);

    T_Sim::get().logSPS = true;
    T_Sim::get().setSpeed(0.016f);

    T_Sim::get().startSimulation();
    P_Sim::get().startSimulation();



    float pause = 0.0f;
    float reloadBreak = 0.0f;
    float spawn1 = 0.0f;
    float spawn2 = 0.0f;

    // auto quad = make<Quad>();
    // hel->add(quad);
    // quad->scale(vec2(100,100));
    // quad->setPosition(vec2(0,300));
    // quad->setCenter(ammo_counter->getCenter());
    
    while (!window.shouldClose()) {
        if(Input::get().keyPressed(KeyCode::K)) { 
             glfwSetInputMode((GLFWwindow*)window.getWindow(), GLFW_CURSOR, GLFW_CURSOR_NORMAL);
             T_Sim::get().stopSimulation();
             P_Sim::get().stopSimulation();
             glfwTerminate();
             return 0;}
        T_Sim::get().flushTasks();
        SimSpeedControl();
        vec2 mIn = inputMove(12.0f);
        ScriptContext ctx;
        one->setLinearVelocity(
            (one->facing()*-mIn.y())+
            (one->right()*-mIn.x()));
        pause -= s_tool.tpf;
        reloadBreak -= s_tool.tpf;
        spawn1 -= s_tool.tpf;
        spawn2 -= s_tool.tpf;

        if(Input::get().keyPressed(KeyCode::R)&&reloadBreak<=0.0f)
        {
            reloadBreak = 4.0f;
            gun->set<int>("ammo",gun->get<int>("max_ammo"));

            text::setTextBefore(std::to_string(gun->get<int>("ammo")),'/',ammo_counter);
        }

        if(Input::get().keyPressed(KeyCode::MOUSE_LEFT)&&pause<=0&&gun->get<int>("ammo")>0)
        {
            pause = 0.6f;
            ScriptContext ctx;
            gun->run("onFire",ctx);
            auto proj = make<H_Object>(make<Model>(MROOT+"bullet.glb"));
            proj->set<str>("dtype","proj");
            hel->add(proj);
            proj->setPhysicsState(P_State::ACTIVE);
            //proj->setPosition(one->getPosition()-one->right().mult(0.2f)+hel->camera.front);
            proj->setPosition(gun->markerPos("fire_point"));
            proj->setLinearVelocity(hel->camera.front.mult(100.0f));
            proj->faceTowards(hel->camera.front);
            proj->addScript("onTick",[hel,proj](ScriptContext& ctx){
                // if(auto g = hel->closestType(proj->getPosition(),"demon"))
                // {
                //     // proj->setLinearVelocity(proj->direction(g).mult(
                //     //     8.0f/proj->distance(g)
                //     // ));
                // }
            });

            proj->addScript("onCollide",[hel,proj](ScriptContext& ctx){
                g_ptr<S_Object> s = ctx.get<g_ptr<S_Object>>("with");
                if(auto h = g_dynamic_pointer_cast<H_Object>(s))
                {
                if(s->get<str>("dtype")=="demon")
                {
                    P_Sim::get().queueTask([hel,h,proj]{
                        hel->removeObject(h);
                        hel->removeObject(proj);
                    });
                    // hel->removeObject(h);
                    // hel->removeObject(proj);

                    // h->stop();
                    // proj->stop();
                }
                }
            });
        }

        if(spawn1<=0)
        {
        spawn1 = 4.3f;
        auto demon = make<H_Object>(make<Model>(MROOT+"demon.glb"));
        demon->set<str>("dtype","demon");
        hel->add(demon);
        demon->setPhysicsState(P_State::ACTIVE);
        demon->setPosition(main->markerPos("spawn_1").addY(0.00f));
        demon->addScript("onTick",[hel,demon](ScriptContext& ctx){
            if(auto g = hel->closestType(demon->getPosition(),"human"))
            {
                demon->setLinearVelocity(demon->direction(g).mult(4.0f).nY());
                demon->faceTo(g->getPosition());  
                ctx.set<int>("damage",1);
                if(demon->distance(g)<=2.0f) g->run("onHit",ctx);   
            }
        });
        }

        if(spawn2<=0)
        {
        spawn2 = 5.3f;
        auto demon = make<H_Object>(make<Model>(MROOT+"demon.glb"));
        demon->set<str>("dtype","demon");
        hel->add(demon);
        demon->setPhysicsState(P_State::ACTIVE);
        demon->setPosition(main->markerPos("spawn_2"));
        demon->addScript("onTick",[hel,demon](ScriptContext& ctx){
            if(auto g = hel->closestType(demon->getPosition(),"human"))
            {
                demon->setLinearVelocity(demon->direction(g).mult(4.0f).nY());
                demon->faceTo(g->getPosition());   
                ctx.set<int>("damage",1);
                if(demon->distance(g)<=2.0f)g->run("onHit",ctx);   
            }
        });
        }

        hel->updateScene(1.0f);
        //one->setLinearVelocity(one->facing());
        //one->getPosition().addY(0.8f)+one->facing().mult(0.5f)
        hel->camera.setPosition(one->markerPos("camera_point"));
        vec3 f = hel->camera.front;
        one->faceTowards(vec3(f.x(),0,f.z()));
        //gun->setPosition(one->getPosition().addY(0.2f)-one->right().mult(0.2f)+hel->camera.front);
        //gun->setPosition(one->model->markers.get("grip_point")+one->getPosition());
        gun->setPosition(one->markerPos("grip_point"));
        gun->faceTowards(hel->camera.front);

        s_tool.tick();

        window.swapBuffers();
        window.pollEvents();
    }


    return 0;
}